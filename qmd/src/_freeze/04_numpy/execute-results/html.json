{
  "hash": "f79036397ad09c706374e23fcbd6d364",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: NumPy\n---\n\n\n\n\n\n\n# What is “NumPy”?\n\n> [The fundamental package for scientific computing with Python.](https://github.com/numpy/numpy)\n\n* **Num**erical **Py**thon\n* It is a package - addition features we can optional add to the Python language.\n\n## On NumPy\n\nBasically, to do scientific computing it would be nice to have:\n\n* a powerful N-dimensional array object\n* sophisticated (broadcasting) functions\n* tools for integrating C/C++ and Fortran code\n* useful linear algebra, Fourier transform, and random number capabilities\n\n(These are the stated features of NumPy.)\n\n## Relevance\n\n* We have essentially been using 1- and 2-dimensional arrays already!\n* Here is the examples `intercepts.py` solution from last time:\n\nCode\n\n::: {#b0fa39f0 .cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\ntaxes = [\n    [9275, .10],\n    [37650, .15],\n    [91150, .25],\n    [190150, .28],\n    [413350, .33],\n    [415051, .35]\n]\n\ncost = 0\nstart = 0\nfor tax in taxes:\n    cost += (tax[0] - start) * tax[1]\n    tax += [cost - tax[0] * tax[1]]\n    start = tax[0]\n```\n:::\n\n\n## We will\n\n* Change our existing _lists_, which we understand as “N-dimensional arrays” into NumPy arrays.\n* Show the benefits of this arrangement.\n* Show other NumPy features.\n\n---\n\n# Package Management\n\n## PyPI\n\n> The Python Package Index (PyPI) is a repository of software for the Python programming language.\n\n* NumPy is a Python package.\n    * It is installed separately from Python, but\n    * May be installed using Python-based tools.\n\n## pip\n\n> The most popular tool for installing Python packages, and the one included with modern versions of Python.\n\n* `pip` is a command line utility\n* For years `pip` was the only real options for installing Python programs, but has experienced limitations as the package ecosystem has grown quite large.\n\n## Using `pip`\n\n* Use as an argument to `python` or `python3`\n\n```{.bash code-line-numbers=\"false\"}\npython3 -m pip install numpy\n```\n\n* It may take a moment to install.\n\n## Verify Install\n\n* The following verifies the the NumPy install was successful\n* We see the return of `import`\n    * Introduce `as`, used to shorten names\n    * We could have done `import piecewise as pw`\n\n::: {#0dc89008 .cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\n\nprint(np.__version__)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2.0.1\n```\n:::\n:::\n\n\n## Recall\n\n* You may wish to review `import`\n* Consult [Neovim -> \\`import’](file:///C:/Users/cd-desk/Documents/repos/scicom/qmd/02_neovim.html#import)\n\n# Arrays\n\n## NumPy Arrays\n\n* The first thing to do in NumPy is make an _array_.\n* In general we use NumPy arrays when:\n    * We are dealing with lists of numbers\n    * We care about performance, or\n    * We want to use advanced mathematical operations\n\n## List to Array\n\n* We define a list of lists:\n\n::: {#4a89c29d .cell execution_count=4}\n``` {.python .cell-code}\ntaxes = [\n    [9275, .10],\n    [37650, .15],\n    [91150, .25],\n    [190150, .28],\n    [413350, .33],\n    [415051, .35]\n]\n```\n:::\n\n\n## Lists of lists\n\n* It is worth while to examine `taxes` a bit\n\n::: {#177cec62 .cell execution_count=5}\n``` {.python .cell-code}\ntaxes\n```\n\n::: {.cell-output .cell-output-display execution_count=1660}\n```\n[[9275, 0.1],\n [37650, 0.15],\n [91150, 0.25],\n [190150, 0.28],\n [413350, 0.33],\n [415051, 0.35]]\n```\n:::\n:::\n\n\n## Check Types\n\n* We can verify it is a list.\n\n```{python{\ntype(taxes)\n```\n\n* We can verify it’s initial element is also a list.\n\n::: {#4631c14e .cell execution_count=6}\n``` {.python .cell-code}\ntype(taxes[0])\n```\n\n::: {.cell-output .cell-output-display execution_count=1661}\n```\nlist\n```\n:::\n:::\n\n\n* Since `taxes[0]` is a list, we can look at _that_ list’s initial element.\n\n::: {#013ce617 .cell execution_count=7}\n``` {.python .cell-code}\ntype(taxes[0][0])\n```\n\n::: {.cell-output .cell-output-display execution_count=1662}\n```\nint\n```\n:::\n:::\n\n\n## Versus arrays\n\n* We have a list of lists of ints (like integers, round numbers).\n* Or do we?\n\n::: {#7519b231 .cell execution_count=8}\n``` {.python .cell-code}\ntype(taxes[0][1])\n```\n\n::: {.cell-output .cell-output-display execution_count=1663}\n```\nfloat\n```\n:::\n:::\n\n\n* In fact, the tax _rates_ are not round numbers, so they are “floats”.\n* NumPy will help us manage when we use “floating point numbers” (have a decimal point) and integers (don’t).\n\n## Niceties\n\n* Each of the internal lists of numbers is of the same length.\n* That lets us do this:\n\n| Cutoff | Rate |\n| -----: | ---- |\n| 9275   | .10  |\n| 37650  | .15  |\n| 91150  | .25  |\n| 190150 | .28  |\n| 413350 | .33  |\n| 415051 | .35  |\n\n## Contingencies\n\n* This… isn’t always true.\n* In our case, for example, we have a .396 rate with _no_ cutoff.\n* We just can’t express this as an array:\n\n| Cutoff | Rate |\n| -----: | --- |\n| 413350 | .33  |\n| 415051 | .35  |\n|        | .396 |\n\n## Takeaways:\n\n* Be ready to deal with things being _almost_ arrays, but ultimately only being lists-of-lists.\n* There’s ways to deal with this (we’ve seen a few, sneakily)\n\n## Arrays\n\n> In computer programming, an array is a structure for storing and retrieving data. We often talk about an array as if it were a grid in space, with each cell storing one element of the data. For instance, if each element of the data were a number, we might visualize a “one-dimensional” array like a list:\n\n\n$$\n    \\begin{array}{|c||c|c|c|}\n    \\hline\n    9275 & 37650 & 91150 & 190150 \\\\\n    \\hline\n    \\end{array}\n$$\n\n## Tables\n\n> A two-dimensional array would be like a table:\n\n$$\n    \\begin{array}{|c||c|c|c|}\n    \\hline\n    9275 & 37650 & 91150 & 190150 \\\\\n    \\hline\n    .10 & .15 & .25 & .28 \\\\\n    \\hline\n    0 & -463.75 & -6963.25 & -16470.75 \\\\\n    \\hline\n    \\end{array}\n$$\n\n## ndarray\n\n> A three-dimensional array would be like a set of tables, perhaps stacked as though they were printed on separate pages. In NumPy, this idea is generalized to an arbitrary number of dimensions, and so the fundamental array class is called `ndarray`: it represents an “N-dimensional array”.\n\n- The most obvious 3d example would be that `taxes` part of an *array* of tax policies\n```{.python}\n[\"Single\", \"Married, joint\", \"Married, separate\", \"Head of Household\"]\n```\n\n## Making Arrays\n\n- Make an array with `np.array()`\n  \t- Or `numpy.array` if you used `import numpy`\n- They look like this:\n\n::: {#75621a6f .cell execution_count=9}\n``` {.python .cell-code}\narr = np.array(taxes)\narr\n```\n\n::: {.cell-output .cell-output-display execution_count=1664}\n```\narray([[9.27500e+03, 1.00000e-01],\n       [3.76500e+04, 1.50000e-01],\n       [9.11500e+04, 2.50000e-01],\n       [1.90150e+05, 2.80000e-01],\n       [4.13350e+05, 3.30000e-01],\n       [4.15051e+05, 3.50000e-01]])\n```\n:::\n:::\n\n\n- Our integers are gone - everything in scientific notation\n\n## Aside: Scientific Notation\n\n> [Scientific notation is a way of expressing numbers that are too large or too small to be conveniently written in decimal form, since to do so would require writing out an inconveniently long string of digits.](https://en.wikipedia.org/wiki/Scientific_notation)\n\n- In scientific notation, nonzero numbers are written in the form \n\n$$a \\times 10^b$$\n\n## Aside: Explanation\n\n\n- In scientific notation, nonzero numbers are written in the form \n\n$$a \\times 10^b$$\n\n\n* $a$ (the coefficient or mantissa) is a number greater than or equal to 1 and less than 10 ($1 \\le |a| < 10$).\n* $10$ is the base.\n* $b$ (the exponent) is an integer.\n\n\n## Aside: Physical Examples\n\n1.  **Speed of light:** The speed of light in a vacuum is approximately $300,000,000 \\text{ m/s}$\n$$\n3 \\times 10^8 \\text{ m/s}\n$$\n\n2.  **Mass of an electron:** The mass of an electron is approximately $0.00000000000000000000000000091093837 \\text{ g}$.\n$$\n9.1093837 \\times 10^{-28} \\text{ g}\n$$\n\n## Aside: Economic Examples\n\n- We can use social science numbers.\n- [Labor Market Outcomes of College Graduates by Major](https://www.newyorkfed.org/research/college-labor-market#--:explore:outcomes-by-major)\n- Computer scientists have a \\$80,000 median wage early career\n\t- $8.0000 \\times 10^4$\n- And 6.1% unemployment\n  \t- $6.1 \\times 10^{-2}$\n\n# Using Arrays\n\n## Inspecting Arrays\n\n- Given some array, we can look up elements in an array as we did with lists.\n- We refer to zero as the \"index\" of the initial element of an array (or list).\n\n:::: {.carr[0]olumns}\n\n::: {.column width=\"50%\"}\n\n::: {#7171392e .cell execution_count=10}\n``` {.python .cell-code}\ntaxes[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=1665}\n```\n[9275, 0.1]\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {#d8cb24a7 .cell execution_count=11}\n``` {.python .cell-code}\narr[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=1666}\n```\narray([9.275e+03, 1.000e-01])\n```\n:::\n:::\n\n\n:::\n\n::::\n\n- We look up the same element by the same index in both Python lists and NumPy arrays.\n\n## Slices\n\n- Python and NumPy support *slicing*\n- This takes multiple elements of an array by specifying a *range* of indices\n- Let's make a one-dimensional array to make matters simpler.\n\n::: {#7b21db7b .cell execution_count=12}\n``` {.python .cell-code}\ncolors = [\"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"indigo\", \"violet\"]\n```\n:::\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {#b0be8866 .cell execution_count=13}\n``` {.python .cell-code}\ncolor_lst = colors\ncolor_lst[1:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=1668}\n```\n['orange', 'yellow', 'green']\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {#e5a67a9c .cell execution_count=14}\n``` {.python .cell-code}\ncolor_arr = np.array(colors)\ncolor_arr[1:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=1669}\n```\narray(['orange', 'yellow', 'green'], dtype='<U6')\n```\n:::\n:::\n\n\n:::\n\n::::\n\n- `dtype` is data type - We'll cover it soon.\n\n## Understanding slices\n\n- The slice `1:4` takes all elements at index beginning at `1` and stopping before getting to index `4`.\n\n$$\n\\small\n\\begin{array}{|l|c|c|c|c|c|c|}\n\\hline\n\\textbf{Index} & 0 & 1 & 2 & 3 & 4 & 5 & 6   \\\\\n\\hline\n\\textbf{Element} & red & orange& yellow& green& blue& indigo& violet\\\\\n\\hline\n\\end{array}\n$$\n\n$$\n\\small\n\\begin{array}{|l|c|c|c|}\n\\hline\n\\textbf{Index} & 1 & 2 & 3   \\\\\n\\hline\n\\textbf{Element} & orange& yellow& green\\\\\n\\hline\n\\end{array}\n$$\n\n## Omiting Values\n\n- If we omit the value before the `:` from the slice, it is treated as if a zero was provided.\n\n::: {#d20c54fb .cell execution_count=15}\n``` {.python .cell-code}\ncolor_arr\n```\n\n::: {.cell-output .cell-output-display execution_count=1670}\n```\narray(['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'],\n      dtype='<U6')\n```\n:::\n:::\n\n\n::: {#d62afdd1 .cell execution_count=16}\n``` {.python .cell-code}\ncolor_arr[0:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=1671}\n```\narray(['red', 'orange', 'yellow', 'green'], dtype='<U6')\n```\n:::\n:::\n\n\n::: {#e5657e45 .cell execution_count=17}\n``` {.python .cell-code}\ncolor_arr[:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=1672}\n```\narray(['red', 'orange', 'yellow', 'green'], dtype='<U6')\n```\n:::\n:::\n\n\n## Omiting End\n\n- If we omit the value after the `:` from the slice, it is as if the length was provided.\n\n::: {#4e844a6a .cell execution_count=18}\n``` {.python .cell-code}\ncolor_arr\n```\n\n::: {.cell-output .cell-output-display execution_count=1673}\n```\narray(['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'],\n      dtype='<U6')\n```\n:::\n:::\n\n\n- `len` gives the length of a list or array\n\n::: {#d69ec0d9 .cell execution_count=19}\n``` {.python .cell-code}\nlen(color_arr)\n```\n\n::: {.cell-output .cell-output-display execution_count=1674}\n```\n7\n```\n:::\n:::\n\n\n::: {#7d662893 .cell execution_count=20}\n``` {.python .cell-code}\ncolor_arr[4:7]\n```\n\n::: {.cell-output .cell-output-display execution_count=1675}\n```\narray(['blue', 'indigo', 'violet'], dtype='<U6')\n```\n:::\n:::\n\n\n::: {#e96a0127 .cell execution_count=21}\n``` {.python .cell-code}\ncolor_arr[4:]\n```\n\n::: {.cell-output .cell-output-display execution_count=1676}\n```\narray(['blue', 'indigo', 'violet'], dtype='<U6')\n```\n:::\n:::\n\n\n## Steps\n \n- Python and NumPy slices have an additional feature I find quite nice called \"steps\"\n- We specify a slice:\n\n::: {#c524f25e .cell execution_count=22}\n``` {.python .cell-code}\ncolor_arr[1:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=1677}\n```\narray(['orange', 'yellow', 'green'], dtype='<U6')\n```\n:::\n:::\n\n\n- We add a *third* value\n\n::: {#4a7a71ab .cell execution_count=23}\n``` {.python .cell-code}\ncolor_arr[1:4:1]\n```\n\n::: {.cell-output .cell-output-display execution_count=1678}\n```\narray(['orange', 'yellow', 'green'], dtype='<U6')\n```\n:::\n:::\n\n\n## Step Size\n\n-- We add a *third* value\n\n::: {#36063527 .cell execution_count=24}\n``` {.python .cell-code}\ncolor_arr[1:4:1]\n```\n\n::: {.cell-output .cell-output-display execution_count=1679}\n```\narray(['orange', 'yellow', 'green'], dtype='<U6')\n```\n:::\n:::\n\n\n- This value determines how far to move over the original array between each element shown.\n  - Let's look at `2` - every other element.\n\n::: {#f942c5be .cell execution_count=25}\n``` {.python .cell-code}\ncolor_arr[1:4:2]\n```\n\n::: {.cell-output .cell-output-display execution_count=1680}\n```\narray(['orange', 'green'], dtype='<U6')\n```\n:::\n:::\n\n\n## Example\n\n- In kindergarten, I learned that red, yellow, and blue were primary colors.\n\t- I'm relatively unconvinced by that at this time, but it's a good example.\n\n::: {#b6de4d69 .cell execution_count=26}\n``` {.python .cell-code}\ncolor_arr\n```\n\n::: {.cell-output .cell-output-display execution_count=1681}\n```\narray(['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'],\n      dtype='<U6')\n```\n:::\n:::\n\n\n- And the primaries:\n\n::: {#9b488665 .cell execution_count=27}\n``` {.python .cell-code}\ncolor_arr[0:5:2]\n```\n\n::: {.cell-output .cell-output-display execution_count=1682}\n```\narray(['red', 'yellow', 'blue'], dtype='<U6')\n```\n:::\n:::\n\n\n## Step Ommissions\n\n- We can omit start, stop, or both and still take steps.\n\n::: {#4d4f6a18 .cell execution_count=28}\n``` {.python .cell-code}\ncolor_arr[::3]\n```\n\n::: {.cell-output .cell-output-display execution_count=1683}\n```\narray(['red', 'green', 'violet'], dtype='<U6')\n```\n:::\n:::\n\n\n- We can use a *negative* step to reverse.\n\n::: {#90f8c2cc .cell execution_count=29}\n``` {.python .cell-code}\ncolor_arr[::-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=1684}\n```\narray(['violet', 'indigo', 'blue', 'green', 'yellow', 'orange', 'red'],\n      dtype='<U6')\n```\n:::\n:::\n\n\n## Aside: Negatives\n\n- Negative starts and stops can also be used\n\n::: {#22b4a4b0 .cell execution_count=30}\n``` {.python .cell-code}\ncolor_arr\n```\n\n::: {.cell-output .cell-output-display execution_count=1685}\n```\narray(['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'],\n      dtype='<U6')\n```\n:::\n:::\n\n\n- They simply measure distance from the end.\n\n::: {#4447aaeb .cell execution_count=31}\n``` {.python .cell-code}\ncolor_arr[:-2]\n```\n\n::: {.cell-output .cell-output-display execution_count=1686}\n```\narray(['red', 'orange', 'yellow', 'green', 'blue'], dtype='<U6')\n```\n:::\n:::\n\n\n## Coordinates\n\n- Versus Python lists-of-lists.\n\n::: {#c077f08b .cell execution_count=32}\n``` {.python .cell-code}\ntaxes[1][1]\n```\n\n::: {.cell-output .cell-output-display execution_count=1687}\n```\n0.15\n```\n:::\n:::\n\n\n- NumPy arrays can specify coordinates - indices of multiple dimensions - in a single set of brackets.\n\n::: {#69d5e265 .cell execution_count=33}\n``` {.python .cell-code}\narr[1][1], arr[1, 1]\n```\n\n::: {.cell-output .cell-output-display execution_count=1688}\n```\n(np.float64(0.15), np.float64(0.15))\n```\n:::\n:::\n\n\n## Coordinate slices\n\n- I recommend using the comma notation.\n- Otherwise I get unexpected behavior.\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {#4efe2435 .cell execution_count=34}\n``` {.python .cell-code}\n# reverse in both dimensions\narr[::-1][::-1] \n```\n\n::: {.cell-output .cell-output-display execution_count=1689}\n```\narray([[9.27500e+03, 1.00000e-01],\n       [3.76500e+04, 1.50000e-01],\n       [9.11500e+04, 2.50000e-01],\n       [1.90150e+05, 2.80000e-01],\n       [4.13350e+05, 3.30000e-01],\n       [4.15051e+05, 3.50000e-01]])\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {#ac206445 .cell execution_count=35}\n``` {.python .cell-code}\n# reverse in both dimensions\narr[::-1,::-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=1690}\n```\narray([[3.50000e-01, 4.15051e+05],\n       [3.30000e-01, 4.13350e+05],\n       [2.80000e-01, 1.90150e+05],\n       [2.50000e-01, 9.11500e+04],\n       [1.50000e-01, 3.76500e+04],\n       [1.00000e-01, 9.27500e+03]])\n```\n:::\n:::\n\n\n:::\n\n::::\n\n- Takeaway:  Always use `[x,y]` instead of `[x][y]`\n- Things like this are we use NumPy!\n\n## Updates\n\n- We can also update entries via `=`\n\n::: {#31e50aea .cell execution_count=36}\n``` {.python .cell-code}\ncolor_arr\n```\n\n::: {.cell-output .cell-output-display execution_count=1691}\n```\narray(['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'],\n      dtype='<U6')\n```\n:::\n:::\n\n\n-  Use (1) name of array, (2) index of element, (3) `=`, (4) new element\n\n::: {#cca6f208 .cell execution_count=37}\n``` {.python .cell-code}\ncolor_arr[-1] = 'purple'\n```\n:::\n\n\n- The array now has that element/index.\n\n::: {#ae28ed7f .cell execution_count=38}\n``` {.python .cell-code}\ncolor_arr\n```\n\n::: {.cell-output .cell-output-display execution_count=1693}\n```\narray(['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'purple'],\n      dtype='<U6')\n```\n:::\n:::\n\n\n# Vectorization\n\n## Why NumPy?\n\n- NumPy vectors can do a *very* cool thing that lists can't.\n- We use it a lot in science.\n- *Vector operations*.\n\n## Vector Ops\n\n- Let's compare Python\n\n::: {#48d1fd7e .cell execution_count=39}\n``` {.python .cell-code}\nl1 = [1,2,3]\nl2 = [1,1,1]\nl1 + l2\n```\n\n::: {.cell-output .cell-output-display execution_count=1694}\n```\n[1, 2, 3, 1, 1, 1]\n```\n:::\n:::\n\n\n- To NumPy\n\n::: {#62d302b5 .cell execution_count=40}\n``` {.python .cell-code}\na1 = np.array(l1)\na2 = np.array(l2)\na1 + a2\n```\n\n::: {.cell-output .cell-output-display execution_count=1695}\n```\narray([2, 3, 4])\n```\n:::\n:::\n\n\n- By the way, vectorization is really fast.\n- Our first \"high performance computing\" idea.\n\n## Example\n\n- Suppose you need to convert some temperatures.\n\n::: {#140bdee3 .cell execution_count=41}\n``` {.python .cell-code}\n# Portland highs and lows 5/26/25-6/2/25 in degF\ntemps = np.array([70, 50, 81, 60, 85, 57, 70, 52, 84, 58, 87, 58, 74, 53, 70, 54])\ntemps -= 32\ntemps *= 5\ntemps //= 9\ntemps\n```\n\n::: {.cell-output .cell-output-display execution_count=1696}\n```\narray([21, 10, 27, 15, 29, 13, 21, 11, 28, 14, 30, 14, 23, 11, 21, 12])\n```\n:::\n:::\n\n\n## Aside: `//`\n\n- NumPy requires arrays to be of a certain kind of number.\n- `30` is an integer.\n- `30/9` is a decimal value...\n- Python furnishes special `//` integer division.\n\t- It truncates (does not round) the result.\n\n::: {#6f86c9bd .cell execution_count=42}\n``` {.python .cell-code}\nnp.array([1,2,3,4,5,6,7,8,9,10]) // 3\n```\n\n::: {.cell-output .cell-output-display execution_count=1697}\n```\narray([0, 0, 1, 1, 1, 2, 2, 2, 3, 3])\n```\n:::\n:::\n\n\n- Try using `/` there. What happens?\n\n## Use case \n\n- Slices and vectorization are *very* useful in the income tax example.\n- We:\n  \t- Had income cutoffs, that were\n\t- The *beginning* of some tax brackets, but\n\t- The *end* of other tax brackets\n\t- Offset by one (`1`)\n\n## Building Brackets\n\n- Let's refresh on what the tax bracket array looked like.\n\n::: {#7793e832 .cell execution_count=43}\n``` {.python .cell-code}\narr\n```\n\n::: {.cell-output .cell-output-display execution_count=1698}\n```\narray([[9.27500e+03, 1.00000e-01],\n       [3.76500e+04, 1.50000e-01],\n       [9.11500e+04, 2.50000e-01],\n       [1.90150e+05, 2.80000e-01],\n       [4.13350e+05, 3.30000e-01],\n       [4.15051e+05, 3.50000e-01]])\n```\n:::\n:::\n\n\n- Initial tax bracket goes zero and to `9275`\n- The next goes from `9275` to `37650`.\n- So `9275` is useful to two brackets.\n\n## Begin and end\n\n- Let's grab just the cutoffs.\n\n::: {#f1efcf4e .cell execution_count=44}\n``` {.python .cell-code}\ncutoffs = arr[:,0]\ncutoffs\n```\n\n::: {.cell-output .cell-output-display execution_count=1699}\n```\narray([  9275.,  37650.,  91150., 190150., 413350., 415051.])\n```\n:::\n:::\n\n\n- `[:, 0]` means for every row (slice `:`) take the initial columns (index `0`)\n\n## Insert\n\n- The initial bracket begins at `0` and the last bracket ends at infinity.\n\t- NumPy knows about infinity! `np.inf`\n- We can use NumPy `insert` to add an element at an index:\n\n::: {#e4769f7c .cell execution_count=45}\n``` {.python .cell-code}\n# Insert to (a) an array at (b) some index (c) some value\na = cutoffs\nb = len(cutoffs)\nc = np.inf\ncutoffs = np.insert(a, b, c)\ncutoffs\n```\n\n::: {.cell-output .cell-output-display execution_count=1700}\n```\narray([  9275.,  37650.,  91150., 190150., 413350., 415051.,     inf])\n```\n:::\n:::\n\n\n## Append\n\n- I usually don't insert, I append.\n- This allows adding two arrays together, like how Python `+` works on lists.\n\n::: {#56683589 .cell execution_count=46}\n``` {.python .cell-code}\n# Smoosh arrays together.\ncutoffs = np.append([0],cutoffs)\ncutoffs\n```\n\n::: {.cell-output .cell-output-display execution_count=1701}\n```\narray([     0.,   9275.,  37650.,  91150., 190150., 413350., 415051.,\n           inf])\n```\n:::\n:::\n\n\n## Slicing\n\n- Now we can take the beginning of every bracket, by index:\n\n::: {#7703d567 .cell execution_count=47}\n``` {.python .cell-code}\nbegin = cutoffs[:-1]\nbegin\n```\n\n::: {.cell-output .cell-output-display execution_count=1702}\n```\narray([     0.,   9275.,  37650.,  91150., 190150., 413350., 415051.])\n```\n:::\n:::\n\n\n- And the end\n\n::: {#3587c6c6 .cell execution_count=48}\n``` {.python .cell-code}\nend = cutoffs[1:]\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1703}\n```\narray([  9275.,  37650.,  91150., 190150., 413350., 415051.,     inf])\n```\n:::\n:::\n\n\n## Vector Minus\n\n- We can see how big each bracket is.\n\n::: {#355fd470 .cell execution_count=49}\n``` {.python .cell-code}\nbracket_size = end - begin\nbracket_size\n```\n\n::: {.cell-output .cell-output-display execution_count=1704}\n```\narray([  9275.,  28375.,  53500.,  99000., 223200.,   1701.,     inf])\n```\n:::\n:::\n\n\n## Vector Times\n\n- We can see how much tax is spent in each bracket.\n  - We will \"cut off\" the last bracket first\n  - It doesn't really have a size?\n\n::: {#9d797e35 .cell execution_count=50}\n``` {.python .cell-code}\nbracket_cost = bracket_size[:-1] * arr[:, 1]\nbracket_cost\n```\n\n::: {.cell-output .cell-output-display execution_count=1705}\n```\narray([  927.5 ,  4256.25, 13375.  , 27720.  , 73656.  ,   595.35])\n```\n:::\n:::\n\n\n- What happens if we don't cut off the last bracket and try to multiply a vector of length `7` by a vector of length `6`?\n\n## Accumulation\n\n- While `bracket_cost` does correctly describe the cost within on bracket, someone in the `n+1`'th bracket pays the cost the previous `n` brackets.\n- Someone how we want to sum those up.\n- NumPy has many built-in array functions, including `np.cumsum`.\n\n::: {#e832ff91 .cell execution_count=51}\n``` {.python .cell-code}\ntotal_cost = np.cumsum(bracket_cost)\ntotal_cost\n```\n\n::: {.cell-output .cell-output-display execution_count=1706}\n```\narray([   927.5 ,   5183.75,  18558.75,  46278.75, 119934.75, 120530.1 ])\n```\n:::\n:::\n\n\n# Takeaways\n\n## NumPy does a lot!\n- [Arrays](https://numpy.org/doc/stable/user/basics.creation.html) mostly, but including:\n- Vector operations called [\"broadcasting\"](https://numpy.org/doc/stable/user/basics.broadcasting.html).\n- [Indices and slices](https://numpy.org/doc/stable/user/basics.indexing.html) matter a lot.\n- [Contants](https://numpy.org/devdocs/reference/constants.html) like `np.inf` support mathematics\n- [Accumulation functions](https://numpy.org/doc/2.1/reference/routines.math.html#sums-products-differences) we don't have to write ourselves (which we'd have to do via loops)\n\n\n# Exercise\n\n## Using NumPy\n\n- Today we successfully recomputed the points of the point-intercept form of the income tax problem.\n- Using NumPy, starting with `taxes`, create the array on the right:\n\n:::: {.columns}\n\n::: {.column width=\"28%\"}\n\n::: {#512b27d9 .cell execution_count=52}\n``` {.python .cell-code}\ntaxes = np.array([\n    [9275, .1],\n    [37650, .15],\n    [91150, .25],\n    [190150, .28],\n    [413350, .33],\n    [415051, .35]\n])\n```\n:::\n\n\n:::\n\n::: {.column width=\"72%\"}\n\n::: {#0a9ce3e2 .cell execution_count=53}\n``` {.python .cell-code}\nnp.array([[ 9.275000e+03,  1.000000e-01,  0.000000e+00],\n          [ 3.765000e+04,  1.500000e-01, -4.637500e+02],\n          [ 9.115000e+04,  2.500000e-01, -4.228750e+03],\n          [ 1.901500e+05,  2.800000e-01, -6.963250e+03],\n          [ 4.133500e+05,  3.300000e-01, -1.647075e+04],\n          [ 4.150510e+05,  3.500000e-01, -2.473775e+04]])\n```\n:::\n\n\n:::\n\n::::\n\n## Transpose\n\n- There are many ways to solve this problem!\n- Things will be easier with the following:\n\n::: {#629feadf .cell execution_count=54}\n``` {.python .cell-code}\ntaxes.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=1708}\n```\n(6, 2)\n```\n:::\n:::\n\n\n::: {#f0158d66 .cell execution_count=55}\n``` {.python .cell-code}\ntaxes.reshape(2,6)\n```\n\n::: {.cell-output .cell-output-display execution_count=1709}\n```\narray([[9.27500e+03, 1.00000e-01, 3.76500e+04, 1.50000e-01, 9.11500e+04,\n        2.50000e-01],\n       [1.90150e+05, 2.80000e-01, 4.13350e+05, 3.30000e-01, 4.15051e+05,\n        3.50000e-01]])\n```\n:::\n:::\n\n\n::: {#378e8937 .cell execution_count=56}\n``` {.python .cell-code}\ntaxes.transpose()\n```\n\n::: {.cell-output .cell-output-display execution_count=1710}\n```\narray([[9.27500e+03, 3.76500e+04, 9.11500e+04, 1.90150e+05, 4.13350e+05,\n        4.15051e+05],\n       [1.00000e-01, 1.50000e-01, 2.50000e-01, 2.80000e-01, 3.30000e-01,\n        3.50000e-01]])\n```\n:::\n:::\n\n\n## Bonus Problem\n\n- NumPy allows random number generation.\n- Generate one million random numbers between, say, `0` and `500000`.\n  - There will be repeats, which is okay.\n- Use Python with and without NumPy to compute every tax cost.\n- See which one is faster! You can use the shell command `time`\n\n## Aside: Random\n\n- The following:\n  - Generates 1 million random integers from `0` to `50000`\n  - Prints every 10 thousandth integer.\n\n::: {#f67d846d .cell execution_count=57}\n``` {.python .cell-code}\nimport numpy as np\nrng = np.random.default_rng()\nincomes = rng.integers(0, 500000, 1000000)\nprint(incomes[::10000])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[171424 241375 285964 125360  52999 285668 236114   8631 296777 275086\n  69544   7141  48955 314649 341799 485625 122729  49679  20994 357012\n 392434 221344 336558 226452 375483 345741 385265 225583 475804 410648\n 179235  74593 421393 220555  17821 334199  64615 445686 146656  42952\n 357075 298365 479620 277589 479153 335044 278464 125162 251349 138905\n 226676 340150 251472 499521 449527 320234  45636 459600 335005 108248\n 441943 167299 465765 111651  74190 412319 481245  92164 417263 115113\n  96599 213059 228416 435661 201962 112303 390120 286936  93713 322928\n 240178 402489 478492 414020 274382 203143  73600 107794 298139 370520\n  52703 480587 187134  78043 266978 416769 192305 368233 467771 381381]\n```\n:::\n:::\n\n\n- Read more: [Random sample](https://numpy.org/doc/stable/reference/random/index.html)\n\n## Aside: `time`\n\n- Use `time` before a command.\n  - `real` time is how much passes in real life\n\n```{.bash code-line-numbers=\"false}\n$ time python3 onemil.py\n[123177 422613 471310 380518  95385 143328 426503 453832 427403 106416\n 327306 476263  65814 281381 422404  59938  14231 232824 342190 329545\n 412684 112339 202498   5071  59114 394601 451216  92268 381107 487447\n  55089 339493 344836 261917 148326 452850 409130 484951 427839 307217\n 259268 485208 331277 183015 132480 345930 439366   6814  39743 268276\n  80739 293355 170394   4220  48082  15668 453927  58059 320294 101182\n   1864 492297 130465   9920  76321 345944 268312 255875  46614 195236\n 233737 443948 343483 116870 165561 326265 103567 327780 475672 392212\n 396479 328248  43273  32596 246212   4258  60202  66783 135035 155327\n 469638 378485 175496 428130 493185 154716 193012 424037 197666 103758]\n\nreal    0m0.155s\nuser    0m1.883s\nsys     0m0.033s\n```\n\n## Solution\n\n::: {#b71520e6 .cell execution_count=58}\n``` {.python .cell-code code-fold=\"true\"}\ncutoffs = taxes[:,0]\nrates = taxes[:,1]\n\n# If you are confused, print(arr) after every line\narr = np.append([0], cutoffs)\narr = arr[1:] - arr[:-1]\narr *= rates\narr = np.cumsum(arr)\narr = arr - cutoffs * rates\n\ntaxes = np.array([cutoffs,rates,arr])\n\ntaxes = taxes.transpose()\n```\n:::\n\n\n## Using it\n\n- I used the exact same `single_tax` function as in the \"Shell\" exercise.\n\n::: {#302be7da .cell execution_count=59}\n``` {.python .cell-code code-fold=\"true\"}\ndef single_tax(income):\n    # Check all brackets\n    for tax in taxes:\n        if income < tax[0]:\n            return income * tax[1] + tax[2]\n    # We calculated the top bracket earlier\n    return income * .396 + -43830.05\n```\n:::\n\n\n",
    "supporting": [
      "04_numpy_files\\figure-revealjs"
    ],
    "filters": [],
    "includes": {}
  }
}