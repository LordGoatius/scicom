[
  {
    "objectID": "01_python.html",
    "href": "01_python.html",
    "title": "A Introduction to Python",
    "section": "",
    "text": "We are going to be using Python since\n\nPython is free,\nPython is very widely used,\nPython is flexible,\nPython is relatively easy to learn,\nand Python is quite powerful.\n\nIt is important to keep in mind that Python is a general purpose language that we will be using for Scientific Computing. The purpose of Scientific Computing is not to build apps, build software, manage databases, or develop user interfaces. Instead, Scientific Computing is the use of a computer programming language (like Python) along with mathematics to solve scientific and mathematical problems. For this reason it is definitely not our purpose to write an all-encompassing guide for how to use Python. We’ll only cover what is necessary for our computing needs. You’ll learn more as the course progresses so use this chapter as a reference just to get going with the language.\nThere is an overwhelming abundance of information available about Python and the suite of tools that we will frequently use.\n\nPython https://www.python.org/,\nnumpy (numerical Python) https://www.numpy.org/,\nmatplotlib (a suite of plotting tools) https://matplotlib.org/,\nscipy (scientific Python) https://www.scipy.org/, and\nsympy (symbolic Python) https://www.sympy.org/en/index.html.\n\nThese tools together provide all of the computational power that will need. And they’re free!\n\n\n\nAs is tradition for a new programming language, we should create code that prints the words “Hello, world!” to the screen. The code below does just that.\nprint(\"Hello, world!\")\n\n## Hello, world!\nIn a Jupyter Notebook you will write your code in a code block, and when you’re ready to run it you can press Shift+Enter (or Control+Enter) and you’ll see your output. Shift+Enter will evaluate your code and advance to the next block of code. Control+Enter will evaluate without advancing the cursor to the next block.\n\n\n\n\n\nVariables in Python can contain letters (lower case or capital), numbers 0-9, and some special characters such as the underscore. Variable names should start with a letter. Of course there are a bunch of reserved words (just like in any other language). You should look up what the reserved words are in Python so you don’t accidentally use them.\nYou can do the typical things with variables. Assignment is with an equal sign (be careful R users, we will not be using the left-pointing arrow here!).\nWarning: When defining numerical variables you don’t always get floating point numbers. In some programming languages, if you write x=1 then automatically x is saved as 1.0; a floating point decimal number, not an integer. However, in Python if you assign x=1 it is defined as an integer (with no decimal digits) but if you assign x=1.0 it is assigned as a floating point number.\n# assign some variables\nx = 7 # integer assignment of the integer 7\ny = 7.0 # floating point assignment of the decimal number 7.0\nprint(\"The variable x is\",x,\" and has type\", type(x),\". \\n\")\nprint(\"The variable y is\",y,\" and has type\", type(y),\". \\n\")\n\n## The variable x is 7  and has type &lt;class 'int'&gt; .\n\n## The variable y is 7.0  and has type &lt;class 'float'&gt; .\n\n# multiplying by a float will convert an integer to a float\nx = 7 # integer assignment of the integer 7\nprint(\"Multiplying x by 1.0 gives\",1.0*x)\n\n## Multiplying x by 1.0 gives 7.0\n\nprint(\"The type of this value is\", type(1.0*x),\". \\n\")\n\n## The type of this value is &lt;class 'float'&gt; .\nNote that the allowed mathematical operations are:\n\nAddition: +\nSubtraction: -\nMultiplication: *\nDivision: /\nInteger Division (modular division): // and\nExponents: **\n\nThat’s right, the caret key, ^, is NOT an exponent in Python (sigh). Instead we have to get used to ** for exponents.\nx = 7.0\ny = x**2 # square the value in x\nprint(y)\n\n## 49.0\n\nExercise A.4 What happens if you type 7^2 into Python? What does it give you? Can you figure out what it is doing?\n\nExercise A.5 Write code to define positive integers \\(a,b,\\) and \\(c\\) of your own choosing. Then calculate \\(a^2\\), \\(b^2\\), and \\(c^2\\). When you have all three values computed, check to see if your three values form a Pythagorean Triple so that \\(a^2 + b^2 = c^2\\). Have Python simply say True or False to verify that you do, or do not, have a Pythagorean Triple defined.\nHint: You will need to use the == Boolean check just like in other programming languages. Some sample output is shown below.\n## a= 3 , b= 4 , c= 5\n\n## a, b, and c form a Pythagorean triple.\n\n## a= 2 , b= 3 , c= 7\n\n## a, b, and c do not form a Pythagorean triple.\n\n\n\n\nLists are a key component to storing data in Python. Lists are exactly what the name says: lists of things (in our case, usually the entries are floating point numbers).\nWarning: Python indexing starts at 0 whereas some other programming languages have indexing starting at 1. We just have to keep this in mind.\nWe can extract a part of a list using the syntax name[start:stop] which extracts elements between index start and stop-1. Take note that Python stops reading at the second to last index. This often catches people off guard when they first start with Python.\nSome things to keep in mind with Python lists:\n\nPython starts indexing at 0\nPython stops reading at the second to last index\nThe following blocks of code show this feature in action for several different lists.\n\n\nExample A.1 (Lists and Indexing) Let’s look at a few examples of indexing from lists. In this example we will use the list of numbers 0 through 8. This list contains 9 numbers indexed from 0 to 8.\n\nCreate the list of numbers 0 through 8 and then print only the element with index 0.\nMyList = [0,1,2,3,4,5,6,7,8] print(MyList[0])\n## 0\nPrint all elements up to, but not including, the third element of MyList.\nMyList = [0,1,2,3,4,5,6,7,8] print(MyList[:2])\n## [0, 1]\nPrint the last element of MyList (this is a handy trick!).\nMyList = [0,1,2,3,4,5,6,7,8] print(MyList[-1])\n## 8\nPrint the elements indexed 1 through 4. Beware! This is not the first through fifth element.\nMyList = [0,1,2,3,4,5,6,7,8] print(MyList[1:5])\n## [1, 2, 3, 4]\nPrint every other element in the list starting with the first.\nMyList = [0,1,2,3,4,5,6,7,8] print(MyList[0::2])\n## [0, 2, 4, 6, 8]\nPrint the last three elements of MyList\nMyList = [0,1,2,3,4,5,6,7,8] print(MyList[-3:])\n## [6, 7, 8]\n\n\nExample A.2 (Range and Lists) Let’s look at another example of indexing in lists. In this one we’ll use the range command to build the initial list of numbers. Read the code carefully so you know what each line does.\n# range is a handy command for creating a sequence of integers\nMySecondList = range(4,20) \nprint(MySecondList) # this is a \"range object\" in Python.  \n# When using range() we won't actually store all of the \n# values in memory.\n\n## range(4, 20)\n\nprint(list(MySecondList)) \n# notice that we didn't create the last element!\n\n## [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n\nprint(MySecondList[0]) # print the first element (index 0)\n\n## 4\n\nprint(MySecondList[-5]) # print the fifth element from the end\n\n## 15\n\nprint(MySecondList[-1:0:-1]) # this creates a new range object.  \n# Take careful note of how the above range object is defined.\n# Print the last element to the one indexed by 1 counting backward\n\n## range(19, 4, -1)\n\nprint(list(MySecondList[-1:0:-1])) \n\n## [19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5]\n\nprint(MySecondList[-1::-1]) # this creates another new range object\n\n## range(19, 3, -1)\n\nprint(list(MySecondList[-1::-1])) # print the whole list backwards\n\n## [19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4]\n\nprint(MySecondList[::2]) # create another new range object\n\n## range(4, 20, 2)\n\nprint(list(MySecondList[::2])) # print every other element \n\n## [4, 6, 8, 10, 12, 14, 16, 18]\n\nIn Python, elements in a list do not need to be the same type. You can mix integers, floats, strings, lists, etc.\n\nExample A.3 In this example we see a list of several items that have different data types: float, integer, string, and complex. Note that the imaginary number \\(i\\) is represented by \\(j\\) in Python. This is common in many scientific disciplines and is just another thing that we’ll need to get used to in Python.\nMixedList = [1.0, 7, 'Bob', 1-1j]\nprint(MixedList)\n\n## [1.0, 7, 'Bob', (1-1j)]\n\nprint(type(MixedList[0]))\n\n## &lt;class 'float'&gt;\n\nprint(type(MixedList[1]))\n\n## &lt;class 'int'&gt;\n\nprint(type(MixedList[2]))\n\n## &lt;class 'str'&gt;\n\nprint(type(MixedList[3])) \n# Notice that we use 1j for the imaginary number \"i\".\n\n## &lt;class 'complex'&gt;\n\nExercise A.6 In this exercise you will put your new list skills into practice.\n\nCreate the list of the first several Fibonacci numbers: \\[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89.\\]\nPrint the first four elements of the list.\nPrint every third element of the list starting from the first.\nPrint the last element of the list.\nPrint the list in reverse order.\nPrint the list starting at the last element and counting backward by every other element.\n\n\n\n\n\nPython is awesome about allowing you to do things like appending items to lists, removing items from lists, and inserting items into lists. Note in all of the examples below that we are using the code\nvariable.command\nwhere you put the variable name, a dot, and the thing that you would like to do to that variable. For example, MyList.append(7) will append the number 7 to the list MyList. This is a common programming feature in Python and we’ll use it often.\n\nExample A.4 (.append) The .append command can be used to append an element to the end of a list.\nMyList = [0,1,2,3]\nprint(MyList)\n\n## [0, 1, 2, 3]\n\nMyList.append('a') # append the string 'a' to the end of the list\nprint(MyList)\n\n## [0, 1, 2, 3, 'a']\n\nMyList.append('a') # do it again ... just for fun\nprint(MyList)\n\n## [0, 1, 2, 3, 'a', 'a']\n\nMyList.append(15) # append the number 15 to the end of the list\nprint(MyList)\n\n## [0, 1, 2, 3, 'a', 'a', 15]\n\nExample A.5 (.remove) The .remove command can be used to remove an element from a list.\nMyList = [0,1,2,3]\nMyList.append('a') # append the string 'a' to the end of the list\nMyList.append('a') # do it again ... just for fun\nMyList.append(15) # append the number 15 to the end of the list\nMyList.remove('a') # remove the first instance of `a` from the list\nprint(MyList)\n\n## [0, 1, 2, 3, 'a', 15]\n\nMyList.remove(3) # now let's remove the 3\nprint(MyList)\n\n## [0, 1, 2, 'a', 15]\n\nExample A.6 (.insert) The .insert command can be used to insert an element at a location in a list.\nMyList = [0,1,2,3]\nMyList.append('a') # append the string 'a' to the end of the list\nMyList.append('a') # do it again ... just for fun\nMyList.append(15) # append the number 15 to the end of the list\nMyList.remove('a') # remove the first instance `a` from the list\nMyList.remove(3) # now let's remove the 3\nprint(MyList)\n\n## [0, 1, 2, 'a', 15]\n\nMyList.insert(0,'A') # insert the letter `A` at the 0-indexed spot\n# insert the letter `B` at the spot with index 3 \nMyList.insert(3,'B') \n# remember that index 3 means the fourth spot in the list\nprint(MyList)\n\n## ['A', 0, 1, 'B', 2, 'a', 15]\n\nExercise A.7 In this exercise you will go a bit further with your list operation skills.\n\nCreate the list of the first several Lucas Numbers: \\(1,3,4,7,11,18,29,47.\\)\nAdd the next three Lucas Numbers to the end of the list.\nRemove the number 3 from the list.\nInsert the 3 back into the list in the correct spot.\nPrint the list in reverse order.\nDo a few other list operations to this list and report your findings.\n\n\n\n\n\nIn Python, a “tuple” is like an ordered pair (or order triple, or order quadruple, …) in mathematics. We will occasionally see tuples in our work in numerical analysis so for now let’s just give a couple of code snippets showing how to store and read them.\nWe can define the tuple of numbers \\((10,20)\\) in Python as follows.\npoint = 10, 20 # notice that I don't need the parenthesis\nprint(point, type(point))\n\n## (10, 20) &lt;class 'tuple'&gt;\nWe can also define a tuple with parenthesis if we like. Python doesn’t care.\npoint = (10, 20) # now we define the tuple with parenthesis\nprint(point, type(point))\n\n## (10, 20) &lt;class 'tuple'&gt;\nWe can then unpack the tuple into components if we wish.\npoint = (10, 20)\nx, y = point\nprint(\"x = \", x)\n\n## x =  10\n\nprint(\"y = \", y)\n\n## y =  20\n\n\n\nAny time you’re doing some repetitive task with a programming language you should actually be using a loop. Just like in other programming languages we can do loops and conditional statements in very easy ways in Python. The thing to keep in mind is that the Python language is very white-space-dependent. This means that your indentations need to be correct in order for a loop to work. You could get away with sloppy indention in other languages but not so in Python. Also, in some languages (like R and Java) you need to wrap your loops in curly braces. Again, not so in Python.\nCaution: Be really careful of the white space in your code when you write loops.\n\n\nA for loop is designed to do a task a certain number of times and then stop. This is a great tool for automating repetitive tasks, but it also nice numerically for building sequences, summing series, or just checking lots of examples. The following are several examples of Python for loops. Take careful note of the syntax for a for loop as it is the same as for other loops and conditional statements:\n\na control statement,\na colon, a new line,\nindent four spaces,\nsome programming statements\n\nWhen you are done with the loop just back out of the indention. There is no need for an end command or a curly brace. All of the control statements in Python are white-space-dependent.\n\nExample A.7 Print the first 6 perfect square.\nfor x in [1,2,3,4,5,6]:\n    print(x**2)\n\n## 1\n## 4\n## 9\n## 16\n## 25\n## 36\n\nExample A.8 Print the names in a list.\nNamesList = ['Alice','Billy','Charlie','Dom','Enrique','Francisco']\nfor name in NamesList:\n    print(name)\n\n## Alice\n## Billy\n## Charlie\n## Dom\n## Enrique\n## Francisco\n\nIn Python you can use a more compact notation for for loops sometimes. This takes a bit of getting used to, but is super slick!\n\nExample A.9 Create a list of the perfect squares from 1 to 9.\n# create a list of the perfect squares from 1 to 9\nCoolList = [x**2 for x in range(1,10)]\nprint(CoolList)\n# Then print the sum of this list\n\n## [1, 4, 9, 16, 25, 36, 49, 64, 81]\n\nprint(\"The sum of the first 9 perfect squares is\",sum(CoolList))\n\n## The sum of the first 9 perfect squares is 285\n\nfor loops can also be used to build recursive sequences as can be seen in the next couple of examples.\n\nExample A.10 In the following code we write a for loop that outputs a list of the first 7 iterations of the sequence \\(x_{n+1}=-0.5x_n+1\\) starting with \\(x_0=3\\). Notice that we’re using the command x.append instead of \\(x[n+1]\\) to append the new term to the list. This allows us to grow the length of the list dynamically as the loop progresses.\nx=[3.0]\nfor n in range(0,7):\n    x.append(-0.5*x[n] + 1)\n    print(x) # print the whole list x at each step of the loop\n\n## [3.0, -0.5]\n## [3.0, -0.5, 1.25]\n## [3.0, -0.5, 1.25, 0.375]\n## [3.0, -0.5, 1.25, 0.375, 0.8125]\n## [3.0, -0.5, 1.25, 0.375, 0.8125, 0.59375]\n## [3.0, -0.5, 1.25, 0.375, 0.8125, 0.59375, 0.703125]\n## [3.0, -0.5, 1.25, 0.375, 0.8125, 0.59375, 0.703125, 0.6484375]\n\nExample A.11 As an alternative to the code from the previous example we can pre-allocate the memory in an array of zeros. This is done with the clever code x = [0] * 10. Literally multiplying a list by some number, like 10, says to repeat that list 10 times.\nNow we’ll build the sequence with pre-allocated memory.\nx = [0] * 7\nx[0] = 3.0\nfor n in range(0,6):\n    x[n+1] = -0.5*x[n]+1\n    print(x) # This print statement shows x at each iteration\n\n## [3.0, -0.5, 0, 0, 0, 0, 0]\n## [3.0, -0.5, 1.25, 0, 0, 0, 0]\n## [3.0, -0.5, 1.25, 0.375, 0, 0, 0]\n## [3.0, -0.5, 1.25, 0.375, 0.8125, 0, 0]\n## [3.0, -0.5, 1.25, 0.375, 0.8125, 0.59375, 0]\n## [3.0, -0.5, 1.25, 0.375, 0.8125, 0.59375, 0.703125]\n\nExercise A.8 We want to sum the first 100 perfect cubes. Let’s do this in two ways.\n\nStart off a variable called Total at 0 and write a for loop that adds the next perfect cube to the running total.\nWrite a for loop that builds the sequence of the first 100 perfect cubes. After the list has been built find the sum with the sum command.\n\nThe answer is: 25,502,500 so check your work.\n\nExercise A.9 Write a for loop that builds the first 20 terms of the sequence \\(x_{n+1}=1-x_n^2\\) with \\(x_0=0.1\\). Pre-allocate enough memory in your list and then fill it with the terms of the sequence. Only print the list after all of the computations have been completed.\n\n\n\n\nA while loop repeats some task (or sequence of tasks) while a logical condition is true. It stops when the logical condition turns from true to false. The structure in Python is the same as with for loops.\n\nExample A.12 Print the numbers 0 through 4 and then the word “done.” We’ll do this by starting a counter variable, i, at 0 and increment it every time we pass through the loop.\ni = 0\nwhile i &lt; 5:\n    print(i)\n    i += 1 # increment the counter\n\n## 0\n## 1\n## 2\n## 3\n## 4\n\nprint(\"done\")\n\n## done\n\nExample A.13 Now let’s use a while loop to build the sequence of Fibonacci numbers and stop when the newest number in the sequence is greater than 1000. Notice that we want to keep looping until the condition that the last term is greater than 1000 – this is the perfect task for a while loop, instead of a for loop, since we don’t know how many steps it will take before we start the task\nFib = [1,1]\nwhile Fib[-1] &lt;= 1000:\n    Fib.append(Fib[-1] + Fib[-2])\nprint(\"The last few terms in the list are:\\n\",Fib[-3:])\n\n## The last few terms in the list are:\n##  [610, 987, 1597]\n\nExercise A.10 Write a while loop that sums the terms in the Fibonacci sequence until the sum is larger than 1000\n\n\n\n\nConditional (if) statements allow you to run a piece of code only under certain conditions. This is handy when you have different tasks to perform under different conditions.\n\nExample A.14 Let’s look at a simple example of an if statement in Python.\nName = \"Alice\"\nif Name == \"Alice\":\n    print(\"Hello, Alice.  Isn't it a lovely day to learn Python?\")\nelse:\n    print(\"You're not Alice.  Where is Alice?\")\n\n## Hello, Alice.  Isn't it a lovely day to learn Python?\n\nName = \"Billy\"\nif Name == \"Alice\":\n    print(\"Hello, Alice.  Isn't it a lovely day to learn Python?\")\nelse:\n    print(\"You're not Alice.  Where is Alice?\")\n\n## You're not Alice.  Where is Alice?\n\nExample A.15 For another example, if we get a random number between 0 and 1 we could have Python print a different message depending on whether it was above or below 0.5. Run the code below several times and you’ll see different results each time.\nNote: We had to import the numpy package to get the random number generator in Python. Don’t worry about that for now. We’ll talk about packages in a moment.\nimport numpy as np\nx = np.random.rand(1,1) # get a random 1x1 matrix using numpy\nx = x[0,0] # pull the entry from the first row and first column\nif x &lt; 0.5:\n    print(x,\" is less than a half\")\nelse:\n    print(x, \"is NOT less than a half\")\n\n## 0.6702695466506146 is NOT less than a half\n(Take note that the output will change every time you run it)\n\nExample A.16 In many programming tasks it is handy to have several different choices between tasks instead of just two choices as in the previous examples. This is a job for the elif command.\nThis is the same code as last time except we will make the decision at 0.33 and 0.67\nimport numpy as np\nx = np.random.rand(1,1) # get a random 1x1 matrix using numpy\nx = x[0,0] # pull the entry from the first row and first column\nif x &lt; 0.33:\n    print(x,\" &lt; 1/3\")\nelif x &lt; 0.67:\n    print(\"1/3 &lt;= \",x,\"&lt; 2/3\")\nelse:\n    print(x, \"&gt;= 2/3\")\n\n## 1/3 &lt;=  0.557138182217778 &lt; 2/3\n(Take note that the output will change every time you run it)\n\nExercise A.11 Write code to give the Collatz Sequence \\[x_{n+1} = \\left\\{ \\begin{array}{ll} x_n / 2, & \\text{\\(x\\_n\\) is even} \\ 3 x_n + 1, & \\text{otherwise} \\end{array} \\right.\\] starting with a positive integer of your choosing. The sequence will converge15 to 1 so your code should stop when the sequence reaches 1.\n\n\n\n\n\nMathematicians and programmers talk about functions in very similar ways, but they aren’t exactly the same. When we say “function” in a programming sense we are talking about a chunk of code that you can pass parameters and expect an output of some sort. This is not unlike the mathematician’s version, but unlike a mathematical function we can have multiple outputs for a programmatic function. We are not going to be talking about symbolic computation on functions in this section. Symbolic computations will have to wait for the ‘sympy’ tutorial.\nIn Python, to define a function we start with def, followed by the function’s name, any input variables in parenthesis, and a colon. The indented code after the colon is what defines the actions of the function.\n\nExample A.17 The following code defines the polynomial \\(f(x) = x^3 + 3x^2 + 3x + 1\\) and then evaluates the function at a point \\(x=2.3\\).\ndef f(x):\n    return(x**3 + 3*x**2 + 3*x + 1)\nf(2.3)\n\n## 35.937\n\nTake careful note of several things in the previous example:\n\nTo define the function we can not just type it like we would see it one paper. This is not how Python recognizes functions. We just have to get used to it.\nOnce we have the function defined we can call upon it just like we would on paper.\nWe cannot pass symbols into this type of function. See the section on sympy in this chapter if you want to do symbolic computation.\n\n\nExercise A.12 Define the function \\(g(n) = n^2 + n + 41\\) as a Python function. Write a loop that gives the output for this function for integers from \\(n=0\\) to \\(n=39\\). It is curious to note that each of these outputs is a prime number (check this on your own). Will the function produce a prime for \\(n=40\\)? For \\(n=41\\)?\n\nExample A.18 One cool thing that you can do with Python functions is call them recursively. That is, you can call the same function from within the function itself. This turns out to be really handy in several mathematical situations.\nNow let’s define a function for the factorial. This function is naturally going to be recursive in the sense that it calls on itself!\ndef Fact(n):\n    if n==0:\n        return(1)\n    else:\n        return( n*Fact(n-1) ) \n        # Note: we are calling the function recursively.\nWhen you run this code there will be no output. You have just defined the function so you can use it later. So let’s use it to make a list of the first several factorials. Note the use of a for loop in the following code.\nFactList = [Fact(n) for n in range(0,10)]\nFactList\n\n## [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]\n\nExample A.19 For this next example let’s define the sequence \\[x_{n+1} = \\left\\{ \\begin{array}{ll} 2x_n, & x_n \\in [0,0.5] \\ 2x_n - 1, & x_n \\in (0.5,1] \\end{array} \\right.\\] as a function and then build a loop to find the first several iterates of the sequence starting at any real number between 0 and 1.\n# Define the function\ndef MySeq(xn):\n    if xn &lt;= 0.5:\n        return(2*xn)\n    else:\n        return(2*xn-1)\n# Now build a sequence with this function\nx = [0.125] # arbitrary starting point\nfor n in range(0,5): # Let's only build the first 5 terms\n    x.append(MySeq(x[-1]))\nprint(x)\n\n## [0.125, 0.25, 0.5, 1.0, 1.0, 1.0]\n\nExample A.20 A fun way to approximate the square root of two is to start with any positive real number and iterate over the sequence \\[x_{n+1} = \\frac{1}{2} x_n + \\frac{1}{x_n}\\] until we are within any tolerance we like of the square root of \\(2\\). Write code that defines the sequence as a function and then iterates in a while loop until we are within \\(10^{-8}\\) of the square root of 2.\nHint: Import the math package so that you get the square root. More about packages in the next section.\nfrom math import sqrt\ndef f(x):\n    return(0.5*x + 1/x)\nx = 1.1 # arbitrary starting point\nprint(\"approximation \\t\\t exact \\t\\t abs error\")\nwhile abs(x-sqrt(2)) &gt; 10**(-8):\n    x = f(x)\n    print(x, sqrt(2), abs(x - sqrt(2)))\n\n## approximation         exact       abs error\n\n## 1.459090909090909 1.4142135623730951 0.04487734671781385\n## 1.414903709997168 1.4142135623730951 0.0006901476240728233\n## 1.4142137306897584 1.4142135623730951 1.6831666327377093e-07\n## 1.4142135623731051 1.4142135623730951 9.992007221626409e-15\n\nExercise A.13 The previous example is a special case of the Babylonian Algorithm for calculating square roots. If you want the square root of \\(S\\) then iterate the sequence \\[x_{n+1} = \\frac{1}{2} \\left( x_n + \\frac{S}{x_n} \\right)\\] until you are within an appropriate tolerance.\nModify the code given in the previous example to give a list of approximations of the square roots of the natural numbers 2 through 20, each to within \\(10^{-8}\\). This problem will require that you build a function, write a ‘for’ loop (for the integers 2-20), and write a ‘while’ loop inside your ‘for’ loop to do the iterations.\n\n\n\n\nUsing def to define a function as in the previous subsection is really nice when you have a function that is complicated or requires some bit of code to evaluate. However, in the case of mathematical functions we have a convenient alternative: lambda Functions.\nThe basic idea of a lambda Function is that we just want to state what the variable is and what the rule is for evaluating the function. This is the most like the way that we write mathematical functions. For example, let’s define the mathematical function \\(f(x) = x^2+3\\) in two different ways.\n\nAs a Python function with def:\ndef f(x): return(x**2+3)\nAs a lambda function:\nf = lambda x: x**2+3\n\nYou can see that in the Lambda Function we are explicitly stating the name of the variable immediately after the word lambda, then we put a colon, and then the function definition.\nNow if we want to evaluate the function at a point, say \\(x=1.5\\), then we can write code just like we would mathematically: \\(f(1.5)\\)\nf = lambda x: x**2+3\nf(1.5) # evaluate the function at x=1.5\n\n## 5.25\nwhere the result is exactly the floating point number we were interested in.\nThe distinct mathematical advantage for using lambda functions is that the code for setting up a Lambda Function is about as close as we’re going to get to a mathematically defined function as we would write it on paper, but the code for evaluating a lambda Function is exactly what we would write on paper. Additionally, there is less coding overhead than for defining a function with the command.\nWe can also define Lambda Functions of several variables. For example, if we want to define the mathematical function \\(f(x,y) = x^2 + xy + y^3\\) we could write the code\nf = lambda x, y: x**2 + x*y + y**3\nIf we wanted the value \\(f(2,4)\\) we could now write the code f(2,4).\n\nExample A.21 You may recall Euler’s Method from your differential equations training. Euler’s Method will give a list of approximate values of the solution to a first order differential equation at given times.\nConsider the differential equation \\(y’ = -0.25y + 2\\) with the initial condition \\(y(0) = 1.1\\). We can define the right-hand side of the differential equation as a lambda Function in our code so that we can call on it over and over again in our Euler’s Method solution. We’ll take 10 Euler steps starting at the proper initial condition. Pay particular attention to how we use the lambda function.\nimport numpy as np\nRightSide = lambda y: -0.25*y + 2 # define the right-hand side\ndt = 0.125 # define the delta t in Euler's method\nt = [0] # initial time\ny = [1.1] # initial condition\nfor n in range(0,10):\n    t.append(t[n] + dt) # increment the time\n    y.append(y[n] + dt*RightSide(y[n])) # approx soln at next pt\nprint(t) # print the times\n\n## [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25]\n\nprint(np.round(y,2)) \n# round the approx y values to 2 decimal places\n\n## [1.1  1.32 1.52 1.73 1.92 2.11 2.3  2.48 2.65 2.81 2.98]\n\nExercise A.14 Go back to Exercise A.12 and repeat this exercise using a lambda Function instead of a Python function.\n\nExercise A.15 Go back tp problem A.13 and repeat this exercise using a lambda function instead of a Python function.\n\n\n\n\nUnlike mathematical programming languages like MATLAB, Maple, or Mathematica, where every package is already installed and ready to use, Python allows you to only load the packages that you might need for a given task. There are several advantages to this along with a few disadvantages.\nAdvantages:\n\nYou can have the same function doing different things in different scenarios. For example, there could be a symbolic differentiation command and a numerical differentiation command coming from different packages that are used in different ways.\nHousekeeping. It is highly advantageous to have a good understanding of where your functions come from. MATLAB, for example, uses the same name for multiple purposes with no indication of how it might behave depending on the inputs. With Python you can avoid that by only importing the appropriate packages for your current use.\nYour code will be ultimately more readable (more on this later).\n\nDisadvantages:\n\nIt is often challenging to keep track of which function does which task when they have exactly the same name. For example, you could be working with the sin() function numerically from the numpy package or symbolically from the sympy package, and these functions will behave differently in Python - even though they are exactly the same mathematically.\nYou need to remember which functions live in which packages so that you can load the right ones. It is helpful to keep a list of commonly used packages and functions at least while you’re getting started.\n\nLet’s start with the math package.\n\nExample A.22 The code below imports the math package into your instance of Python and calculates the cosine of \\(\\pi/4\\).\nimport math\nx = math.cos(math.pi / 4)\nprint(x)\n\n## 0.7071067811865476\nThe answer, unsurprisingly, is the decimal form of \\(\\sqrt{2}/2\\).\n\nYou might already see a potential disadvantage to Python’s packages: there is now more typing involved! Let’s fix this. When you import a package you could just import all of the functions so they can be used by their proper names.\n\nExample A.23 Here we import the entire math package so we can use every one of the functions therein without having to use the math prefix.\nfrom math import * # read this as: from math import everything\nx = cos(pi / 4)\nprint(x)\n\n## 0.7071067811865476\nThe end result is exactly the same: the decimal form of \\(\\sqrt{2}/2\\), but now we had less typing to do.\n\nNow you can freely use the functions that were imported from the math package. There is a disadvantage to this, however. What if we have two packages that import functions with the same name. For example, in the math package and in the numpy package there is a cos() function. In the next block of code we’ll import both math and numpy, but instead we will import them with shortened names so we can type things a bit faster.\n\nExample A.24 Here we import math and numpy under aliases so we can use the shortened aliases and not mix up which functions belong to which packages.\nimport math as ma\nimport numpy as np\n# use the math version of the cosine function\nx = ma.cos( ma.pi / 4) \n# use the numpy version of the cosine function\ny = np.cos( np.pi / 4) \nprint(x, y)\n\n## 0.7071067811865476 0.7071067811865476\nBoth x and y in the code give the decimal approximation of \\(\\sqrt{2}/2\\). This is clearly pretty redundant in this really simple case, but you should be able to see where you might want to use this and where you might run into troubles.\n\nExample A.25 (Contents of a Library) Once you have a package imported you can see what is inside of it using the dir command. The following block of code prints a list of all of the functions inside the math package.\nimport math\nprint(dir(math))\n\nOf course, there will be times when you need help with a function. You can use the help command to view the help documentation for any function. For example, you can run the code help(math.acos) to get help on the arc cosine function from the math package.\n\nExercise A.16 Import the math package, figure out how the log function works, and write code to calculate the logarithm of the number 8.3 in base 10, base 2, base 16, and base \\(e\\) (the natural logarithm).\n\n\n\n\n\nThe base implementation of Python includes the basic programming language, the tools to write loops, check conditions, build and manipulate lists, and all of the other things that we saw in the previous section. In this section we will explore the package numpy that contains optimized numerical routines for doing numerical computations in scientific computing.\n\nExample A.26 To start with let’s look at a really simple example. Say you have a list of real numbers and you want to take the sine every element in the list. If you just try to take the sine of the list you will get an error. Try it yourself.\nfrom math import pi, sin\nMyList = [0,pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]\nsin(MyList)\nYou could get around this error using some of the tools from base Python, but none of them are very elegant from a programming perspective.\nfrom math import pi, sin\nMyList = [0,pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]\nSineList = [sin(n) for n in MyList]\nprint(SineList)\n\nfrom math import pi, sin\nMyList = [0,pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]\nSineList = [ ]\nfor n in range(0,len(MyList)):\n    SineList.append( sin(MyList[n]) )\nprint(SineList)\n\nThe package numpy is used in many (most) mathematical computations in numerical analysis using Python. It provides algorithms for matrix and vector arithmetic. Furthermore, it is optimized to be able to do these computations in the most efficient possible way (both in terms of memory and in terms of speed).\nTypically when we import numpy we use import numpy as np. This is the standard way to name the numpy package. This means that we will have lots of function with the prefix “np” in order to call on the numpy commands. Let’s first see what is inside the package with the code print(dir(np)) after importing numpy as np. A brief glimpse through the list reveals a huge wealth of mathematical functions that are optimized to work in the best possible way with the Python language. (We are intentionally not showing the output here since it is quite extensive, run it so you can see.)\n\n\nIn the previous section you worked with Python lists. As we pointed out, the shortcoming of Python lists is that they don’t behave well when we want to apply mathematical functions to the vector as a whole. The “numpy array”, np.array, is essentially the same as a Python list with the notable exception that\n\nIn a numpy array every entry is a floating point number\nIn a numpy array the memory usage is more efficient (mostly since Python is expecting data of all the same type)\nWith a numpy array there are ready-made functions that can act directly on the array as a matrix or a vector\n\nLet’s just look at a few examples. What we’re going to do is to define a matrix \\(A\\) and vectors \\(v\\) and \\(w\\) as \\[A = \\begin{pmatrix} 1 & 2 \\ 3 & 4 \\end{pmatrix}, \\quad v = \\begin{pmatrix} 5\\\\6 \\end{pmatrix} \\quad \\text{and} \\quad w = v^T = \\begin{pmatrix} 5 & 6 \\end{pmatrix}.\\] Then we’ll do the following\n\nGet the size and shape of these arrays\nGet individual elements, rows, and columns from these arrays\nTreat these arrays as with linear algebra to\n\ndo element-wise multiplication\ndo matrix a vector products\ndo scalar multiplication\ntake the transpose of matrices\ntake the inverse of matrices\n\n\n\nExample A.27 (numpy Matrices) The first thing to note is that a matrix is a list of lists (each row is a list).\nimport numpy as np\nA = np.array([[1,2],[3,4]])\nprint(\"The matrix A is:\\n\",A)\n\n## The matrix A is:\n##  [[1 2]\n##  [3 4]]\n\nv = np.array([[5],[6]]) # this creates a column vector\nprint(\"The vector v is:\\n\",v)\n\n## The vector v is:\n##  [[5]\n##  [6]]\n\nw = np.array([5,6]) # this creates a row vector\nprint(\"The vector w is:\\n\",w)\n\n## The vector w is:\n##  [5 6]\n\nExample A.28 (variable.shape) The variable.shape command can be used to give the shape of a numpy array. Notice that the output is a tuple showing the size (rows, columns). Also notice that the row vector doesn’t give (1,2) as expected. Instead it just gives (2,).\nimport numpy as np\nA = np.array([[1,2],[3,4]])\nprint(A.shape) # Shape of the matrix A\n\n## (2, 2)\n\nv = np.array([[5],[6]])\nprint(v.shape) # Shape of the column vector v\n\n## (2, 1)\n\nw = np.array([5,6])\nprint(w.shape) # Shape of the row vector w\n\n## (2,)\n\nExample A.29 (variable.size) The variable.size command can be used to give the size of a numpy array. The size of a matrix or vector will be the total number of elements in the array. You can think of this as the product of the values in the tuple coming from the shape command.\nimport numpy as np\nA = np.array([[1,2],[3,4]])\nv = np.array([[5],[6]])\nw = np.array([5,6])\nprint(A.size) # Size (number of elements) of A\n\n## 4\n\nprint(v.size) # Size (number of elements) of v\n\n## 2\n\nprint(w.size) # Size (number of elements) of w\n\n## 2\n\nReading individual elements from a numpy array is the same, essentially, as reading elements from a Python list. We will use square brackets to get the row and column. Remember that the indexing all starts from 0, not 1!\nExample A.30 Let’s read the top left and bottom right entries of the matrix \\(A\\).\nimport numpy as np\nA = np.array([[1,2],[3,4]])\nprint(A[0,0]) # top left\n\n## 1\n\nprint(A[1,1]) # bottom right\n\n## 4\n\nExample A.31 Let’s read the first row from that matrix \\(A\\).\nimport numpy as np\nA = np.array([[1,2],[3,4]])\nprint(A[0,:])\n\n## [1 2]\n\nExample A.32 Let’s read the second column from the matrix \\(A\\).\nimport numpy as np\nA = np.array([[1,2],[3,4]])\nprint(A[:,1])\n\n## [2 4]\nNotice when we read the column it was displayed as a column. Be careful. Reading a column from a matrix will automatically flatten it into an array, not a matrix.\n\nIf we try to multiply either \\(A\\) and \\(v\\) or \\(A\\) and \\(A\\) we will get some funky results. Unlike programming languages like MATLAB, the default notion of multiplication is NOT matrix multiplication. Instead, the default is element-wise multiplication.\n\nExample A.33 If we write the code A*A we do NOT do matrix multiplication. Instead we do element-by-element multiplication. This is a common source of issues when dealing with matrices and linear algebra in Python.\nimport numpy as np\nA = np.array([[1,2],[3,4]])\n# Notice that A*A is NOT the same as A*A with matrix mult.\nprint(A * A) \n\n## [[ 1  4]\n##  [ 9 16]]\n\nExample A.34 If we write A * v Python will do element-wise multiplication across each column since \\(v\\) is a column vector.\nimport numpy as np\nA = np.array([[1,2],[3,4]])\nv = np.array([[5],[6]])\nprint(A * v) \n# A * v will do element wise multiplication on each column\n\n## [[ 5 10]\n##  [18 24]]\n\nIf, however, we recast these arrays as matrices we can get them to behave as we would expect from Linear Algebra. It is up to you to check that these products are indeed correct from the definitions of matrix multiplication from Linear Algebra.\nExample A.35 Recasting the numpy arrays as matrices allows you to use multiplication as we would expect from linear algebra.\nimport numpy as np\nA = np.matrix([[1,2],[3,4]])\nv = np.matrix([[5],[6]])\nw = np.matrix([5,6])\nprint(\"The product A*A is:\\n\",A*A)\n\n## The product A*A is:\n##  [[ 7 10]\n##  [15 22]]\n\nprint(\"The product A*v is:\\n\",A*v)\n\n## The product A*v is:\n##  [[17]\n##  [39]]\n\nprint(\"The product w*A is:\\n\",w*A)\n\n## The product w*A is:\n##  [[23 34]]\n\nIt remains to show some of the other basic linear algebra operations: inverses, determinants, the trace, and the transpose.\n\nExample A.36 (Matrix Transpose) Taking the transpose of a matrix (swapping the rows and columns) is done with the matrix.T command. This is just like other array commands we have seen in Python (like .append, .remove, .shape, etc.).\nimport numpy as np\nA = np.matrix([[1,2],[3,4]])\nprint(A.T) # The transpose is relatively simple\n\n## [[1 3]\n##  [2 4]]\n\nExample A.37 (Matrix Inverse) The inverse of a square matrix is done with A.I.\nimport numpy as np\nA = np.matrix([[1,2],[3,4]])\nAinv = A.I # Taking the inverse is also pretty simple\nprint(Ainv)\n\n## [[-2.   1. ]\n##  [ 1.5 -0.5]]\n\nprint(A * Ainv) # check that we get the identity matrix back\n\n## [[1.0000000e+00 0.0000000e+00]\n##  [8.8817842e-16 1.0000000e+00]]\n\nExample A.38 (Matrix Determinant) The determinant command is hiding under the linalg subpackage inside numpy. Therefore we need to call it as such.\nimport numpy as np\nA = np.matrix([[1,2],[3,4]])\n# The determinant is inside the numpy.linalg package\nprint(np.linalg.det(A)) \n\n## -2.0000000000000004\n\nExample A.39 (Trace of a Matrix) The trace is done with matrix.trace()\nimport numpy as np\nA = np.matrix([[1,2],[3,4]])\nprint(A.trace()) # The trace is pretty darn easy too\n\n## [[5]]\nOddly enough, the trace returns a matrix, not a scalar Therefore you’ll have to read the first entry (index [0,0]) from the answer to just get the trace.\n\nExercise A.17 Now that we can do some basic linear algebra with numpy it is your turn. Define the matrix \\(B\\) and the vector \\(u\\) as\n\\[B = \\begin{pmatrix} 1 & 4 & 8 \\ 2 & 3 & -1 \\ 0 & 9 & -3 \\end{pmatrix} \\quad \\text{and} \\quad u = \\begin{pmatrix} 6 \\ 3 \\ -7 \\end{pmatrix}.\\]\nThen find\n\n\\(Bu\\)\n\\(B^2\\) (in the traditional linear algebra sense)\nThe size and shape of \\(B\\)\n\\(B^T u\\)\nThe element-by-element product of \\(B\\) with itself\nThe dot product of \\(u\\) with the first row of \\(B\\)\n\n\n\n\n\nThere are a few built-in ways to build arrays in numpy that save a bit of time in many scientific computing settings.\n\narange (array range) builds an array of floating point numbers with the arguments start, stop, and step. Note that you may not actually get to the stop point if the distance stop-start is not evenly divisible by the ‘step.’\nlinspace (linearly spaced points) builds an array of floating point numbers starting at one point, ending at the next point, and have exactly the number of points specified with equal spacing in between: start, stop, number of points. In a linear space you are always guaranteed to hit the stop point exactly, but you don’t have direct control over the stop size.\nThe zeros and ones commands create matrices of zeros or ones.\nmeshgrid builds two arrays that when paired make up the ordered pairs for a 2D (or higher D) mesh grid of points. This is the same as the meshgrid command in MATLAB.\n\nNote: Just like with all Python lists, the “stop” number is the one immediately after where you intended to stop.\n\nExample A.40 (np.arange) The np.arange command is great for building sequences.\nimport numpy as np\nx = np.arange(0,0.6,0.1)\nprint(x)\n\n## [0.  0.1 0.2 0.3 0.4 0.5]\n\nExample A.41 (np.linspace) The np.linspace command builds a list with equal (linear) spacing between the starting and ending values.\nimport numpy as np\ny = np.linspace(0,5,11)\nprint(y)\n\n## [0.  0.5 1.  1.5 2.  2.5 3.  3.5 4.  4.5 5. ]\n\nExample A.42 (np.zeros) The np.zeros command builds an array of zeros. This is handy for pre-allocating memory.\nimport numpy as np\nz = np.zeros((3,5)) # create a 3x5 matrix of zeros\nprint(z)\n\n## [[0. 0. 0. 0. 0.]\n##  [0. 0. 0. 0. 0.]\n##  [0. 0. 0. 0. 0.]]\n\nExample A.43 (np.ones) The np.ones command builds an array of ones.\nimport numpy as np\nu = np.ones((3,5)) # create a 3x5 matrix of ones\nprint(u)\n\n## [[1. 1. 1. 1. 1.]\n##  [1. 1. 1. 1. 1.]\n##  [1. 1. 1. 1. 1.]]\n\nExample A.44 (mesh grid) The np.meshgrid command creates a mesh grid. This is handy for building 2D (or higher dimensional) arrays of data for multi-variable functions. Notice that the output is defined as a tuple.\nimport numpy as np\nx, y = np.meshgrid( np.linspace(0,5,6) , np.linspace(0,5,6) )\nprint(\"x = \", x)\n\n## x =  [[0. 1. 2. 3. 4. 5.]\n##  [0. 1. 2. 3. 4. 5.]\n##  [0. 1. 2. 3. 4. 5.]\n##  [0. 1. 2. 3. 4. 5.]\n##  [0. 1. 2. 3. 4. 5.]\n##  [0. 1. 2. 3. 4. 5.]]\n\nprint(\"y = \", y)\n\n## y =  [[0. 0. 0. 0. 0. 0.]\n##  [1. 1. 1. 1. 1. 1.]\n##  [2. 2. 2. 2. 2. 2.]\n##  [3. 3. 3. 3. 3. 3.]\n##  [4. 4. 4. 4. 4. 4.]\n##  [5. 5. 5. 5. 5. 5.]]\nThe thing to notice with the np.meshgrid() command is that when you lay the two matrices on top of each other, the matching entries give every ordered pair in the domain.\n\nExercise A.18 Now time to practice with some of these numpy commands.\n\nCreate a numpy array of the numbers 1 through 10 and square every entry in the list without using a loop.\nCreate a \\(10 \\times 10\\) identity matrix and change the top right corner to a 5. Hint: np.identity()\nFind the matrix-vector product of the answer to part (a) (as a column) and the answer to part (b).\nChange the bottom row of your matrix from part (b) to all 3’s, then change the third column to all 7’s, and then find the \\(5^{th}\\) power of this matrix.\n\n\n\n\n\n\nA key part of scientific computing is plotting your results or your data. The tool in Python best-suited to this task is the package matplotlib. As with all of the other packages in Python, it is best to learn just the basics first and then to dig deeper later. One advantage to using matplotlib in Python is that it is modeled off of MATLAB’s plotting tools. People coming from a MATLAB background should feel pretty comfortable here, but there are some differences to be aware of.\nNote: The reader should note that we will NOT be plotting symbolically defined functions in this section. The plot command that we will be using is reserved for numerically defined plots (i.e. plots of data points), not functions that are symbolically defined. If you have a symbolically defined function and need a plot, then pick a domain, build some \\(x\\) data, use the function to build the corresponding \\(y\\) data, and use the plotting tools discussed here. If you need a plot of a symbolic function and for some reason these steps are too much to ask, then look to the section of this Appendix on sympy.\n\n\nWe are going to start right away with an example. In this example, however, we’ll walk through each of the code chunks one-by-one so that we understand how to set up a proper plot. Something to keep in mind. The author strongly encourages students and readers to use Jupyter Notebooks for their Python coding. As such, there are some tricks for getting the plots to render that only apply to Jupyter Notebooks. If you are using Google Colab then you may not need some of these little tricks.\n\nExample A.45 (Plotting with matplotlib) In the first example we want to simply plot the sine function on the domain \\(x \\in [0,2\\pi]\\), color it green, put a grid on it, and give a meaningful legend and axis labels. To do so we first need to take care of a couple of housekeeping items.\n\nImport numpy so we can take advantage of some good numerical routines.\nImport matplotlib’s pyplot module. The standard way to pull it is in is with the nickname plt (just like with numpy when we import it as np).\nimport numpy as np import matplotlib.pyplot as plt\n\nIn Jupyter Notebooks the plots will not show up unless you tell the notebook to put them “inline.” Usually we will use the following command to get the plots to show up. You do not need to do this in Google Colab. The percent sign is called a magic command in Jupyter Notebooks. This is not a Python command, but it is a command for controlling the Jupyter IDE specifically.\n%matplotlib inline\nNow we’ll build a numpy array of \\(x\\) values (using the np.linspace command) and a numpy array of \\(y\\) values for the sine function.\n# 100 equally spaced points from 0 to 2pi\nx = np.linspace(0,2*np.pi, 100) \ny = np.sin(x)\n\nFinally, build the plot with plt.plot(). The syntax is: plt.plot(x, y, ’color’, ...) where you have several options that you can pass (more on that later).\nNotice that we send the plot legend in directly to the plot command. This is optional and could set the legend up separately if we like.\nThen we’ll add the grid with plt.grid()\nThen we’ll add the legend to the plot\nFinally we’ll add the axis labels\nWe end the plotting code with plt.show() to tell Python to finally show the plot. This line of code tells Python that you’re done building that plot.\nplt.plot(x,y, ‘green’, label=‘The Sine Function’) plt.grid() plt.legend() plt.xlabel(“x axis”) plt.ylabel(“y axis”) plt.show()\n\n\n\n\nThe sine function\n\n\nFigure A.1: The sine function\n\nExample A.46 Now let’s do a second example, but this time we want to show four different plots on top of each other. When you start a figure, matplotlib is expecting all of those plots to be layered on top of each other.(Note:For MATLAB users, this means that you do not need the hold on command since it is automatically “on.”)\nIn this example we will plot \\[y_0 = \\sin(2\\pi x) \\quad y_1 = \\cos(2 \\pi x) \\quad y_2 = y_0 + y_1 \\quad \\text{and} \\quad y_3 = y_0 - y_1\\] on the domain \\(x \\in [0,1]\\) with 100 equally spaced points. We’ll give each of the plots a different line style, built a legend, put a grid on the plot, and give axis labels.\nimport numpy as np\nimport matplotlib.pyplot as plt\n# %matplotlib inline # you may need this in Jupyter Notebooks\n\n# build the x and y values\nx = np.linspace(0,1,100)\ny0 = np.sin(2*np.pi*x)\ny1 = np.cos(2*np.pi*x)\ny2 = y0 + y1\ny3 = y0 - y1\n\n# plot each of the functions \n# (notice that they will be on the same axes)\nplt.plot(x, y0, 'b-.', label=r\"$y_0 = \\sin(2\\pi x)$\")\nplt.plot(x, y1, 'r--', label=r\"$y_1 = \\cos(2\\pi x)$\")\nplt.plot(x, y2, 'g:', label=r\"$y_2 = y_0 + y_1$\")\nplt.plot(x, y3, 'k-', label=r\"$y_3 = y_0 - y_1$\")\n\n# put in a grid, legend, title, and axis labels\nplt.grid()\nplt.legend()\nplt.title(\"Awesome Title\")\nplt.xlabel('x axis label')\nplt.ylabel('y axis label')\nplt.show()\n\n\n\nPlots of the sine, cosine, and sums and differences.\n\n\nFigure A.2: Plots of the sine, cosine, and sums and differences.\nNotice that the legend was placed automatically. There are ways to control the placement of the legend if you wish, but for now just let Python and matplotlib have control over the placement.\n\nExample A.47 Now let’s create the same plot with slightly different code. The plot command can take several \\((x, y)\\) pairs in the same line of code. This can really shrink the amount of coding that you have to do when plotting several functions on top of each other.\n# The next line of code does all of the plotting of all \n# of the functions.  Notice the order: x, y, color and \n# line style, repeat\nimport numpy as np\nimport matplotlib.pyplot as plt\nx = np.linspace(0,1,100)\ny0 = np.sin(2*np.pi*x)\ny1 = np.cos(2*np.pi*x)\ny2 = y0 + y1\ny3 = y0 - y1\nplt.plot(x, y0, 'b-.', x, y1, 'r--', x, y2, 'g:', x, y3, 'k-')\n\nplt.grid()\nplt.legend([r\"$y_0 = \\sin(2\\pi x)$\",r\"$y_1 = \\cos(2\\pi x)$\",\\\n            r\"$y_2 = y_0 + y_1$\",r\"$y_3 = y_0 - y_1$\"])\nplt.title(\"Awesome Title\")\nplt.xlabel('x axis label')\nplt.ylabel('y axis label')\nplt.show()\n\n\n\nA second plot of the sine, cosine, and sums and differences.\n\n\nFigure A.3: A second plot of the sine, cosine, and sums and differences.\n\nExercise A.19 Plot the functions \\(f(x) = x^2\\), \\(g(x) = x^3\\), and \\(h(x) = x^4\\) on the same axes. Use the domain \\(x \\in [0,1]\\) and the range \\(y \\in [0,1]\\). Put a grid, a legend, a title, and appropriate labels on the axes.\n\n\n\n\nIt is often very handy to place plots side-by-side or as some array of plots. The subplots command allows us that control. The main idea is that we are setting up a matrix of blank plots and then populating the axes with the plots that we want.\n\nExample A.48 Let’s repeat the previous exercise, but this time we will put each of the plots in its own subplot. There are a few extra coding quirks that come along with building subplots so we’ll highlight each block of code separately.\n\nFirst we set up the plot area with plt.subplots(). The first two inputs to the subplots command are the number of rows and the number of columns in your plot array. For the first example we will do 2 rows of plots with 2 columns – so there are four plots total. The last input for the subplots command is the size of the figure (this is really just so that it shows up well in Jupyter Notebooks – spend some time playing with the figure size to get it to look right).\nThen we build each plot individually telling matplotlib which axes to use for each of the things in the plots.\nNotice the small differences in how we set the titles and labels\nIn this example we are setting the \\(y\\)-axis to the interval \\([-2,2]\\) for consistency across all of the plots.\n# set up the blank matrix of plots import numpy as np import matplotlib.pyplot as plt x = np.linspace(0,1,100) y0 = np.sin(2np.pix) y1 = np.cos(2np.pix) y2 = y0 + y1 y3 = y0 - y1\nfig, axes = plt.subplots(nrows = 2, ncols = 2, figsize = (10,5))\n# Build the first plot axes[0,0].plot(x, y0, ‘b-.’) axes[0,0].grid() axes[0,0].set_title(r”\\(y_0 = \\sin(2\\pi x)\\)“) axes[0,0].set_ylim(-2,2) axes[0,0].set_xlabel(”x”) axes[0,0].set_ylabel(“y”)\n# Build the second plot axes[0,1].plot(x, y1, ‘r–’) axes[0,1].grid() axes[0,1].set_title(r”\\(y_1 = \\cos(2\\pi x)\\)“) axes[0,1].set_ylim(-2,2) axes[0,1].set_xlabel(”x”) axes[0,1].set_ylabel(“y”)\n# Build the first plot axes[1,0].plot(x, y2, ‘g:’) axes[1,0].grid() axes[1,0].set_title(r”\\(y_2 = y_0 + y_1\\)“) axes[1,0].set_ylim(-2,2) axes[1,0].set_xlabel(”x”) axes[1,0].set_ylabel(“y”)\n# Build the first plot axes[1,1].plot(x, y3, ‘k-’) axes[1,1].grid() axes[1,1].set_title(r”\\(y_3 = y_0 - y_1\\)“) axes[1,1].set_ylim(-2,2) axes[1,1].set_xlabel(”x”) axes[1,1].set_ylabel(“y”)\nfig.tight_layout() plt.show()\n\nThe fig.tight_layout() command makes the plot labels a bit more readable in this instance (again, something you can play with).\n\n\n\nAn example of subplots\n\n\nFigure A.4: An example of subplots\n\nExercise A.20 Put the functions \\(f(x) = x^2\\), \\(g(x) = x^3\\) and \\(h(x) = x^4\\) in a subplot environment with 1 row and 3 columns of plots. Use the unit interval as the domain and range for all three plot, but sure that each plot has a grid, appropriate labels, an appropriate title, and the overall figure has a title.\n\n\n\n\nIt is occasionally useful to scale an axis logarithmically. This arises most often when we’re examining an exponential function, or some other function, that is close to zero for much of the domain. Scaling logarithmically allows us to see how small the function is getting in orders of magnitude instead of as a raw real number. We’ll use this often in numerical methods.\n\nExample A.49 In this example we’ll plot the function \\(y = 10^{-0.01x}\\) on a regular (linear) scale and on a logarithmic scale on the \\(y\\) axis. Use the interval \\([0,500]\\).\nimport numpy as np\nimport matplotlib.pyplot as plt\nx = np.linspace(0,500,1000)\ny = 10**(-0.01*x)\nfig, axis = plt.subplots(1,2, figsize = (10,5))\n\naxis[0].plot(x,y, 'r')\naxis[0].grid()\naxis[0].set_title(\"Linearly scaled y axis\")\naxis[0].set_xlabel(\"x\")\naxis[0].set_ylabel(\"y\")\n\naxis[1].semilogy(x,y, 'k--')\naxis[1].grid()\naxis[1].set_title(\"Logarithmically scaled y axis\")\naxis[1].set_xlabel(\"x\")\naxis[1].set_ylabel(\"Log(y)\")\nplt.show()\nIt should be noted that the same result can be achieved using the yscale command along with the plot command instead of using the semilogy command. Pay careful attention to the subtle changes in the following code.\nimport numpy as np\nimport matplotlib.pyplot as plt\nx = np.linspace(0,500,1000)\ny = 10**(-0.01*x)\nfig, axis = plt.subplots(1,2, figsize = (10,5))\n\naxis[0].plot(x,y, 'r')\naxis[0].grid()\naxis[0].set_title(\"Linearly scaled y axis\")\naxis[0].set_xlabel(\"x\")\naxis[0].set_ylabel(\"y\")\n\naxis[1].plot(x,y, 'k--') # &lt;----- Notice the change here\naxis[1].set_yscale(\"log\") # &lt;----- And we added this line\naxis[1].grid()\naxis[1].set_title(\"Logarithmically scaled y axis\")\naxis[1].set_xlabel(\"x\")\naxis[1].set_ylabel(\"Log(y)\")\n\n\n\nAn example of using logarithmic scaling.\n\n\nFigure A.5: An example of using logarithmic scaling.\n\nExercise A.21 Plot the function \\(f(x) = x^3\\) for \\(x \\in [0,1]\\) on linearly scaled axes, logarithmic axis in the \\(y\\) direction, logarithmically scaled axes in the \\(x\\) direction, and a log-log plot with logarithmic scaling on both axes. Use subplots to put your plots side-by-side. Give appropriate labels, titles, etc.\n\n\n\n\n\nIn this section we will learn the tools necessary to do symbolic mathematics in Python. The relevant package is sympy (symbolic Python) and it works much like Mathematica, Maple, or MATLAB’s symbolic toolbox. That being said, Mathematica and Maple are designed to do symbolic computation in the fastest and best possible ways, so in some sense, sympy is a little step-sibling to these much bigger pieces of software. Remember: Python is free, and this is a book on numerical analysis – we will not be doing much symbolic work in this particular class, but these tools do occasionally come in handy.\nLet’s import sympy in the usual way. We will use the nickname sp (just like we used np for numpy). This is not a standard nickname in the Python literature, but it will suffice for our purposes.\n\nExercise A.22 Load sympy and use the dir() command to see what functions are inside the sympy library.\n\nExample A.50 If you include the command sp.init_printing() after you load sympy you will get some nice LaTeX style output in your Jupyter Notebooks.\n\n\n\nWhen you are working with symbolic variables you have to tell Python that that’s what you’re doing. In other words, we actually have to type-cast the variables when we name them. Otherwise Python won’t know what to do with them – we need to explicitly tell it that we are working with symbols!\n\nExample A.51 Let’s define the variable \\(x\\) as a symbolic variable. Then we’ll define a few symbolic expressions that use \\(x\\) as a variable.\nimport sympy as sp\nx = sp.Symbol('x') # note the capitalization\nNow we’ll define the function \\(f(x) = (x+2)^3\\) and spend the next few examples playing with it.\nf = (x+2)**3 # A symbolic function\nprint(f)\n\n## (x + 2)**3\nNotice that the output of these lines of code is not necessarily very nicely formatted as a symbolic expression. What we would really want to see is \\(\\displaystyle (x+2)^3\\). If you include the code sp.init_printing() after you import the sympy library then you should get nice LaTeX style formatting in your answers.\n\nExample A.52 Be careful that you are using symbolically defined function along with your symbols. For example, see the code below:\n# this line gives an error since it doesn't know \n# which \"sine\" to use.\ng = sin(x) \n\nimport sympy as sp\nx = sp.Symbol('x')\ng = sp.sin(x) # this one works\nprint(g)\n\n## sin(x)\n\n\n\n\nOne of the primary purposes of doing symbolic programming is to do symbolic algebra (the other is typically symbolic calculus). In this section we’ll look at a few of the common algebraic exercises that can be handled with sympy.\n\nExample A.53 (symbolic expand) Expand the function \\(f(x) = (x+2)^3\\). In other words, multiply this out fully so that it is a sum or difference of monomials instead of the cube of a binomial.\nimport sympy as sp\nx = sp.Symbol('x')\nf = (x+2)**3\nsp.expand(f) # do the multiplication to expand the polynomial\n\n## x**3 + 6*x**2 + 12*x + 8\n\nExample A.54 (symbolic factoring) We will factor the polynomial \\(h(x) = x^2 + 4x + 3\\).\nimport sympy as sp\nx = sp.Symbol('x')\nh = x**2 + 4*x + 3\nsp.factor(h) # factor this polynomial\n\n## (x + 1)*(x + 3)\n\nExample A.55 (Trigonometric Simplification) The sympy package knows how to work with trigonometric identities. In this example we show how sympy expands \\(\\sin(a+b)\\).\nimport sympy as sp\na, b = sp.symbols('a b')\nj = sp.sin(a+b)\nsp.expand(j, trig=True) # Trig identities are built in!\n\n## sin(a)*cos(b) + sin(b)*cos(a)\n\nExample A.56 (Symbolic Simplification) In this example we will simplify the function \\(g(x) = x^3 + 5x^3 + 12x^2 +1\\).\nimport sympy as sp\nx = sp.Symbol('x')\ng = x**3 + 5*x**3 + 12*x**2 + 1\nsp.simplify(g) # Simplify some algebraic expression\n\n## 6*x**3 + 12*x**2 + 1\n\nExample A.57 In this example we’ll simplify an expression that involves trigonometry.\nimport sympy as sp\nx = sp.Symbol('x')\nsp.simplify( sp.sin(x) / sp.cos(x)) # simplify a trig expression.\n\n## tan(x)\n\nExample A.58 (Symbolic Equation Solving) The primary goal of many algebra problems is to solve an equation. We will dedicate more time to algebraic equation solving later in this section, but this example gives a simple example of how it works in sympy.\nWe want to solve the equation \\(x^2 + 4x + 3 = 0\\) for \\(x\\).\nimport sympy as sp\nx = sp.Symbol('x')\nh = x**2 + 4*x + 3\nsp.solve(h,x)\n\n## [-3, -1]\nAs expected, the roots of the function \\(h(x)\\) are \\(x=-3\\) and \\(x=1\\) since \\(h(x)\\) factors into \\(h(x) = (x+3)(x-1)\\).\n\n\n\n\nIn sympy we cannot simply just evaluate functions as we would on paper. Let’s say we have the function \\(f(x)= (x+2)^3\\) and we want to find \\(f(5)\\). We would say that we “substitute 5 into f for x,” and that is exactly what we have to tell Python. Unfortunately we cannot just write f(5) since that would mean that f is a Python function and we are sending the number 5 into that function. This is an unfortunate double-use of the word “function,” but stop and think about it for a second: When we write f = (x+2)**3 we are just telling Python that f is a symbolic expression in terms of the symbol x, but we did not use def to define it as a function as we did for all other function.\n\nExample A.59 The following code is what the mathematicians in us would like to do:\nimport sympy as sp\nx = sp.Symbol('x')\nf = (x+2)**3\nf(5) # This gives an error!\n… but this is how it should be done:\nimport sympy as sp\nx = sp.Symbol('x')\nf = (x+2)**3\nf.subs(x,5) # This actually substitutes 5 for x in f\n\n## 343\n\n\n\n\nThe sympy package has routines to take symbolic derivatives, antiderivatives, limits, and Taylor series just like other computer algebra systems.\n\n\nThe diff command in sympy does differentiation: sp.diff(function, variable, [order]).\nTake careful note that diff is defined both in sympy and in numpy. That means that there are symbolic and numerical routines for taking derivatives in Python …and we need to tell our instance of Python which one we’re working with every time we use it.\n\nExample A.60 (Symbolic Differentiation) In this example we’ll differentiate the function \\(f(x) = (x+2)^3\\).\nimport sympy as sp \nx = sp.Symbol('x') # Define the symbol x\nf = (x+2)**3 # Define a symbolic function f(x) = (x+2)^3\ndf = sp.diff(f,x) # Take the derivative of f and call it \"df\"\nprint(\"f(x) = \", f)\n\n## f(x) =  (x + 2)**3\n\nprint(\"f'(x) = \",df)\n\n## f'(x) =  3*(x + 2)**2\n\nprint(\"f'(x) = \", sp.expand(df))\n\n## f'(x) =  3*x**2 + 12*x + 12\n\nExample A.61 Now let’s get the first, second, third, and fourth derivatives of the function f.\nimport sympy as sp \nx = sp.Symbol('x') # Define the symbol x\nf = (x+2)**3 # Define a symbolic function f(x) = (x+2)^3\ndf = sp.diff(f,x,1) # first derivative\nddf = sp.diff(f,x,2) # second deriative\ndddf = sp.diff(f,x,3) # third deriative\nddddf = sp.diff(f,x,4) # fourth deriative\nprint(\"f'(x) = \",df)\n\n## f'(x) =  3*(x + 2)**2\n\nprint(\"f''(x) = \",sp.simplify(ddf))\n\n## f''(x) =  6*x + 12\n\nprint(\"f'''(x) = \",sp.simplify(dddf))\n\n## f'''(x) =  6\n\nprint(\"f''''(x) = \",sp.simplify(ddddf))\n\n## f''''(x) =  0\n\nExample A.62 Now let’s do some partial derivatives. The diff command is still the right tool. You just have to tell it which variable you’re working with.\nimport sympy as sp\nx, y = sp.symbols('x y') # Define the symbols\nf = sp.sin(x*y) + sp.cos(x**2) # Define the function\nfx = sp.diff(f,x)\nfy = sp.diff(f,y)\nprint(\"f(x,y) = \", f)\n\n## f(x,y) =  sin(x*y) + cos(x**2)\n\nprint(\"f_x(x,y) = \", fx)\n\n## f_x(x,y) =  -2*x*sin(x**2) + y*cos(x*y)\n\nprint(\"f_y(x,y) = \", fy)\n\n## f_y(x,y) =  x*cos(x*y)\n\nExample A.63 It is worth noting that when you have a symbolically defined function you can ask sympy to give you the LaTeX code for the symbolic function so you can use it when you write about it.\nimport sympy as sp\nx, y = sp.symbols('x y') # Define the symbols\nf = sp.sin(x*y) + sp.cos(x**2) # Define the function\nsp.latex(f)\n\n## '\\\\sin{\\\\left(x y \\\\right)} + \\\\cos{\\\\left(x^{2} \\\\right)}'\n\n\n\n\nFor integration, the sp.integrate tool is the command for the job: sp.integrate(function, variable) will find an antiderivative and sp.integrate(function, (variable, lower, upper)) will evaluate a definite integral.\nThe integrate command in sympy accepts a symbolically defined function along with the variable of integration and optional bounds. If the bounds aren’t given then the command finds the antiderivative. Otherwise it finds the definite integral.\n\nExample A.64 Find the antiderivative of the function \\(f(x) = (x+2)^3\\).\nimport sympy as sp \nx = sp.Symbol('x')\nf = (x+2)**3\nF = sp.integrate(f,x)\nprint(F)\n\n## x**4/4 + 2*x**3 + 6*x**2 + 8*x\nThe output of these lines of code is the expression \\(\\frac{x^{4}}{4} + 2 x^{3} + 6 x^{2} + 8 x\\) which is indeed the antiderivative.\n\nExample A.65 Consider the multivariable antiderivative \\[\\int \\sin(xy) + \\cos(x) dx.\\] The sympy package deals with the second variable just as it should.\nimport sympy as sp \nx, y = sp.symbols('x y')\ng = sp.sin(x*y) + sp.cos(x)\nG = sp.integrate(g,x) \nprint(G)\n\n## Piecewise((-cos(x*y)/y, Ne(y, 0)), (0, True)) + sin(x)\nIt is apparent that sympy was sensitive to the fact that there was some trouble at \\(y=0\\) and took care of it with a piece wise function.\n\nExample A.66 Consider the integral \\[\\int_0^\\pi \\sin(x) dx.\\] Notice that the variable and the bounds are sent to the integrate command as a tuple. Furthermore, notice that we had to send the symbolic version of \\(\\pi\\) instead of any other version (e.g. numpy).\nimport sympy as sp\nx = sp.Symbol('x')\nsp.integrate( sp.sin(x), (x,0,sp.pi))\n\n## 2\n\nExample A.67 This is a fun one. Let’s do the definite integral \\[\\int_{-\\infty}^\\infty e{-x2} dx.\\] We have to use the “infinity” symbol from sympy. It is two lower-case O’s next to each other: oo. It kind of looks like and infinity I suppose.\nimport sympy as sp\nx = sp.Symbol('x')\nsp.integrate( sp.exp(-x**2) , (x, -sp.oo, sp.oo))\n\n## sqrt(pi)\n\n\n\n\nThe limit command in sympy takes symbolic limits: sp.limit(function, variable, value, [direction])\nThe direction (left or right) is optional and if you leave it off then the limit is considered from both directions.\n\nExample A.68 Let’s take the limit \\[\\lim_{x \\to 0} \\frac{\\sin(x)}{x}.\\]\nimport sympy as sp\nx = sp.Symbol('x')\nsp.limit( sp.sin(x)/x, x, 0)\n\n## 1\n\nExample A.69 Let’s do the difference quotient \\[\\lim_{h \\to 0} \\frac{ f(x+h) - f(x)}{h}\\] for the function \\(f(x) = (x+2)^3\\). Taking the limit should give the derivative so we’ll check that the diff command gives us the same thing using == …warning!\nimport sympy as sp\nx = sp.Symbol('x')\nf = (x+2)**3\nprint(sp.diff(f,x))\n\n## 3*(x + 2)**2\n\nh = sp.Symbol('h')\ndf = sp.limit( (f.subs(x,x+h) - f) / h , h , 0 )\nprint(df)\n\n## 3*x**2 + 12*x + 12\n\nprint(df == sp.diff(f,x)) \n# notice that these are not \"symbolically\" equal\n\n## False\n\nprint(df == sp.expand(sp.diff(f,x))) # but these are\n\n## True\nNotice that when we check to see if two symbolic functions are equal they must be in the same exact symbolic form. Otherwise sympy won’t recognize them as actually being equal even though they are mathematically equivalent.\n\nExercise A.23 Define the function \\(f(x) = 3x^2 + x\\sin(x^2)\\) symbolically and then do the following:\n\nEvaluate the function at \\(x=2\\) and get symbolic and numerical answers.\nTake the first and second derivative\nTake the antiderivative\nFind the definite integral from 0 to 1\nFind the limit as \\(x\\) goes to 3\n\n\n\n\n\nThe sympy package has a tool for expanding Taylor Series of symbolic functions: sp.series( function, variable, [center], [num terms]).\nThe center defaults to \\(0\\) and the number of terms defaults to \\(5\\).\n\nExample A.70 Find the Taylor series for \\(f(x) = e^x\\) centered at \\(x=0\\) and centered at \\(x=1\\).\nimport sympy as sp\nx = sp.Symbol('x')\nsp.series( sp.exp(x),x)\n\n## 1 + x + x**2/2 + x**3/6 + x**4/24 + x**5/120 + O(x**6)\n\nimport sympy as sp\nx = sp.Symbol('x')\nsp.series( sp.exp(x), x, 1, 3) # expand at x=1 (3 terms)\n\n## E + E*(x - 1) + E*(x - 1)**2/2 + O((x - 1)**3, (x, 1))\nFinally, if we want more terms then we can send the number of desired terms to the series command.\nimport sympy as sp\nx = sp.Symbol('x')\nsp.series( sp.exp(x), x, 0, 3) # expand at x=0 and give 3 terms\n\n## 1 + x + x**2/2 + O(x**3)\n\n\n\n\n\nOne of the big reasons to use a symbolic toolboxes such as sympy is to solve algebraic equations exactly. This isn’t always going to be possible, but when it is we get some nice results. The solve command in sympy is the tool for the job: sp.solve( equation, variable )\nThe equation doesn’t actually need to be the whole equation. For any equation-solving problem we can always re-frame it so that we are solving \\(f(x) = 0\\) by subtracting the right-hand side of the equation to the left-hand side. Hence we can leave the equal sign and the zero off and sympy understands what we’re doing.\n\nExample A.71 Let’s solve the equation \\(x^2 - 2 = 0\\) for \\(x\\). We know that the roots are \\(\\pm \\sqrt{2}\\) so this should be pretty trivial for a symbolic solver.\nimport sympy as sp\nx = sp.Symbol('x')\nsp.solve( x**2 - 2, x)\n\n## [-sqrt(2), sqrt(2)]\n\nExample A.72 Now let’s solve the equation \\(x^4 - x^2 - 1= 0\\) for \\(x\\). You might recognize this as a quadratic equation in disguise so you can definitely do it by hand … if you want to. (You could also recognize that this equation is related to the golden ratio!)\nimport sympy as sp\nx = sp.Symbol('x')\nsp.solve( x**4 - x**2 - 1, x)\nRun the code yourself to see the output. In nicer LaTeX style formatting, the answer is \\[\\left[ - i \\sqrt{- \\frac{1}{2} + \\frac{\\sqrt{5}}{2}},  i \\sqrt{- \\frac{1}{2} + \\frac{\\sqrt{5}}{2}},  - \\sqrt{\\frac{1}{2} + \\frac{\\sqrt{5}}{2}},  \\sqrt{\\frac{1}{2} + \\frac{\\sqrt{5}}{2}}\\right]\\] Notice that sympy has no problem dealing with the complex roots.\n\nIn the previous example the answers may be a bit hard to read due to their symbolic form. This is particularly true for far more complicated equation solving problems. The next example shows how you can loop through the solutions and then print them in decimal form so they are a bit more readable.\n\nExample A.73 We will again solve the equation \\(x^4 - x^2 - 1= 0\\) for \\(x\\), but this time we will output the answers as floating point decimals. We are using the N command to convert from symbolic to numerical.\nimport sympy as sp\nx = sp.Symbol('x')\nsoln = sp.solve( x**4 - x**2 - 1, x)\nfor j in range(0, len(soln)):\n    print(sp.N(soln[j]))\n\n## -0.786151377757423*I\n## 0.786151377757423*I\n## -1.27201964951407\n## 1.27201964951407\nThe N command gives a numerical approximation for a symbolic expression (this is taken straight from Mathematica!).\n\nExercise A.24 Give the exact and floating point solutions to the equation \\(x^4 - x^2 - x + 5 = 0\\).\n\nWhen you want to solve a symbolic equation numerically you can use the nsolve command. This will do something like Newton’s method in the background. You need to give it a starting point where it can look for you the solution to your equation: sp.nsolve( equation, variable, intial guess )\n\nExample A.74 Let’s solve the equation \\(x^3 - x^2 - 2\\) for \\(x\\) both symbolically and numerically. The numerical solution with nsolve will search for the solution near \\(x=1\\).\nimport sympy as sp\nx = sp.Symbol('x')\nExactSoln = sp.solve(x**3 - x**2 - 2, x) # symbolic solution\nprint(ExactSoln)\nRun the code yourself to see the exact solution. In nicer LaTeX style formatting the answer is: \\[\\begin{aligned} \\left[ \\frac{1}{3} + \\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{87}}{9} + \\frac{28}{27}} + \\frac{1}{9 \\left(- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{87}}{9} + \\frac{28}{27}}}, \\right. \\ \\frac{1}{3} + \\frac{1}{9 \\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{87}}{9} + \\frac{28}{27}}} + \\left(- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\right) \\sqrt[3]{\\frac{\\sqrt{87}}{9} + \\frac{28}{27}}, \\ \\left. \\frac{1}{9 \\sqrt[3]{\\frac{\\sqrt{87}}{9} + \\frac{28}{27}}} + \\frac{1}{3} + \\sqrt[3]{\\frac{\\sqrt{87}}{9} + \\frac{28}{27}}\\right]\\end{aligned}\\] which is rather challenging to read. We can give all of the floating point approximations with the following code.\nimport sympy as sp\nx = sp.Symbol('x')\nExactSoln = sp.solve(x**3 - x**2 - 2, x) # symbolic solution\nprint(\"First Solution: \",sp.N(ExactSoln[0]))\n\n## First Solution:  -0.347810384779931 - 1.02885225413669*I\n\nprint(\"Second Solution: \",sp.N(ExactSoln[1]))\n\n## Second Solution:  -0.347810384779931 + 1.02885225413669*I\n\nprint(\"Third Solution: \",sp.N(ExactSoln[2]))\n\n## Third Solution:  1.69562076955986\nIf we were only looking for the floating point real solution near \\(x=1\\) then we could just use nsolve.\nimport sympy as sp\nx = sp.Symbol('x')\nNumericalSoln = sp.nsolve(x**3 - x**2 - 2, x, 1) # solution near x=1\nprint(NumericalSoln)\n\n## 1.69562076955986\n\nExercise A.25 Solve the equation \\[x^3 \\ln(x) = 7\\] and give your answer both symbolically and numerically.\n\n\n\n\nIn this final section we will show how to make plots of symbolically defined functions. Be careful here. There are times when you want to plot a symbolically defined function and there are times when you want to plot data: sp.plot( function, (variable, left, right) )\nIt is easy to get confused since they both use the plot function in their own packages (sympy and matplotlib respectively).\nNote: For MATLAB users, the sympy.plot command is similar to MATLAB’s ezplot command or fplot command.\nIn numerical analysis we do not often need to make plots of symbolically defined functions. There is more that could be said about sympy’s plotting routine, but since it won’t be used often in this text it doesn’t seem necessary to give those details here. When you need to make a plot just make a careful consideration as to whether you need a symbolic plot (with sympy) or a plot of data points (with matplotlib).\n\nExample A.75 Let’s get a quick plot of the function \\(f(x) = (x+2)^3\\) on the domain \\(x \\in [-5,2]\\).\nimport sympy as sp\nx = sp.Symbol('x')\nf = (x+2)**3\nsp.plot(f,(x,-5,2))\n\n\n\nA plot of a symbolically defined function.\n\n\nFigure A.6: A plot of a symbolically defined function.\n\nExample A.76 Multiple plots can be done at the same time with the sympy.plot command.\nPlot \\(f(x) = (x+2)^3\\) and \\(g(x) = 20\\cos(x)\\) on the same axes on the domain \\(x \\in [-5,2]\\).\nimport sympy as sp\nx = sp.Symbol('x')\nf = (x+2)**3\ng = 20*sp.cos(x)\nsp.plot(f, g, (x,-5,2))\n\n\n\nA second plot of symbolically defined functions.\n\n\nFigure A.7: A second plot of symbolically defined functions.\n\nExercise A.26 Make a symbolic plot of the function \\(f(x) = x^3 \\ln(x) - 7\\) on the domain \\([0,3]\\).\n\n\nActually, it is still an open mathematical question that every integer seed will converge to 1. The Collatz sequence has been checked for many millions of initial seeds and they all converge to 1, but there is no mathematical proof that it will always happen.↩︎"
  },
  {
    "objectID": "01_python.html#a.1-why-python",
    "href": "01_python.html#a.1-why-python",
    "title": "",
    "section": "A.1 Why Python?",
    "text": "A.1 Why Python?\nWe are going to be using Python since\n\nPython is free,\nPython is very widely used,\nPython is flexible,\nPython is relatively easy to learn,\nand Python is quite powerful.\n\nIt is important to keep in mind that Python is a general purpose language that we will be using for Scientific Computing. The purpose of Scientific Computing is not to build apps, build software, manage databases, or develop user interfaces. Instead, Scientific Computing is the use of a computer programming language (like Python) along with mathematics to solve scientific and mathematical problems. For this reason it is definitely not our purpose to write an all-encompassing guide for how to use Python. We’ll only cover what is necessary for our computing needs. You’ll learn more as the course progresses so use this chapter as a reference just to get going with the language.\nThere is an overwhelming abundance of information available about Python and the suite of tools that we will frequently use.\n\nPython https://www.python.org/,\nnumpy (numerical Python) https://www.numpy.org/,\nmatplotlib (a suite of plotting tools) https://matplotlib.org/,\nscipy (scientific Python) https://www.scipy.org/, and\nsympy (symbolic Python) https://www.sympy.org/en/index.html.\n\nThese tools together provide all of the computational power that will need. And they’re free!"
  },
  {
    "objectID": "01_python.html#hello-world",
    "href": "01_python.html#hello-world",
    "title": "Python",
    "section": "Hello, World!",
    "text": "Hello, World!\n\nprint(\"Hello, world!\")\n\nHello, world!\n\n\n\nprint is a function\n\nIt is a built-in function\n\n() are used to call”* a function\nDouble quotes \"\" are used to enclose a string of characters\n\nSingle quotes '' may also be used.\nOnly stay “string” instead of “word” as may be multiple words, an email address, etc."
  },
  {
    "objectID": "01_python.html#a.4-python-programming-basics",
    "href": "01_python.html#a.4-python-programming-basics",
    "title": "Python",
    "section": "A.4 Python Programming Basics",
    "text": "A.4 Python Programming Basics\nA.4.1 Variables\nVariables in Python can contain letters (lower case or capital), numbers 0-9, and some special characters such as the underscore. Variable names should start with a letter. Of course there are a bunch of reserved words (just like in any other language). You should look up what the reserved words are in Python so you don’t accidentally use them.\nYou can do the typical things with variables. Assignment is with an equal sign (be careful R users, we will not be using the left-pointing arrow here!).\nWarning: When defining numerical variables you don’t always get floating point numbers. In some programming languages, if you write x=1 then automatically x is saved as 1.0; a floating point decimal number, not an integer. However, in Python if you assign x=1 it is defined as an integer (with no decimal digits) but if you assign x=1.0 it is assigned as a floating point number.\n# assign some variables\nx = 7 # integer assignment of the integer 7\ny = 7.0 # floating point assignment of the decimal number 7.0\nprint(\"The variable x is\",x,\" and has type\", type(x),\". \\n\")\nprint(\"The variable y is\",y,\" and has type\", type(y),\". \\n\")\n\n## The variable x is 7  and has type &lt;class 'int'&gt; .\n\n## The variable y is 7.0  and has type &lt;class 'float'&gt; .\n\n# multiplying by a float will convert an integer to a float\nx = 7 # integer assignment of the integer 7\nprint(\"Multiplying x by 1.0 gives\",1.0*x)\n\n## Multiplying x by 1.0 gives 7.0\n\nprint(\"The type of this value is\", type(1.0*x),\". \\n\")\n\n## The type of this value is &lt;class 'float'&gt; .\nNote that the allowed mathematical operations are:\n\nAddition: +\nSubtraction: -\nMultiplication: *\nDivision: /\nInteger Division (modular division): // and\nExponents: **\n\nThat’s right, the caret key, ^, is NOT an exponent in Python (sigh). Instead we have to get used to ** for exponents.\nx = 7.0\ny = x**2 # square the value in x\nprint(y)\n\n## 49.0"
  },
  {
    "objectID": "01_python.html#a.5-numerical-python-with-numpy",
    "href": "01_python.html#a.5-numerical-python-with-numpy",
    "title": "Python",
    "section": "A.5 Numerical Python with numpy",
    "text": "A.5 Numerical Python with numpy\nThe base implementation of Python includes the basic programming language, the tools to write loops, check conditions, build and manipulate lists, and all of the other things that we saw in the previous section. In this section we will explore the package numpy that contains optimized numerical routines for doing numerical computations in scientific computing."
  },
  {
    "objectID": "01_python.html#a.6-plotting-with-matplotlib",
    "href": "01_python.html#a.6-plotting-with-matplotlib",
    "title": "Python",
    "section": "A.6 Plotting with matplotlib",
    "text": "A.6 Plotting with matplotlib\nA key part of scientific computing is plotting your results or your data. The tool in Python best-suited to this task is the package matplotlib. As with all of the other packages in Python, it is best to learn just the basics first and then to dig deeper later. One advantage to using matplotlib in Python is that it is modeled off of MATLAB’s plotting tools. People coming from a MATLAB background should feel pretty comfortable here, but there are some differences to be aware of.\nNote: The reader should note that we will NOT be plotting symbolically defined functions in this section. The plot command that we will be using is reserved for numerically defined plots (i.e. plots of data points), not functions that are symbolically defined. If you have a symbolically defined function and need a plot, then pick a domain, build some \\(x\\) data, use the function to build the corresponding \\(y\\) data, and use the plotting tools discussed here. If you need a plot of a symbolic function and for some reason these steps are too much to ask, then look to the section of this Appendix on sympy.\nA.6.1 Basics with plt.plot()\nWe are going to start right away with an example. In this example, however, we’ll walk through each of the code chunks one-by-one so that we understand how to set up a proper plot. Something to keep in mind. The author strongly encourages students and readers to use Jupyter Notebooks for their Python coding. As such, there are some tricks for getting the plots to render that only apply to Jupyter Notebooks. If you are using Google Colab then you may not need some of these little tricks."
  },
  {
    "objectID": "01_python.html#a.7-symbolic-python-with-sympy",
    "href": "01_python.html#a.7-symbolic-python-with-sympy",
    "title": "Python",
    "section": "A.7 Symbolic Python with sympy",
    "text": "A.7 Symbolic Python with sympy\nIn this section we will learn the tools necessary to do symbolic mathematics in Python. The relevant package is sympy (symbolic Python) and it works much like Mathematica, Maple, or MATLAB’s symbolic toolbox. That being said, Mathematica and Maple are designed to do symbolic computation in the fastest and best possible ways, so in some sense, sympy is a little step-sibling to these much bigger pieces of software. Remember: Python is free, and this is a book on numerical analysis – we will not be doing much symbolic work in this particular class, but these tools do occasionally come in handy.\nLet’s import sympy in the usual way. We will use the nickname sp (just like we used np for numpy). This is not a standard nickname in the Python literature, but it will suffice for our purposes."
  },
  {
    "objectID": "aims.html#announcements",
    "href": "aims.html#announcements",
    "title": "Aims of Education",
    "section": "Announcements",
    "text": "Announcements\n\nWelcome to residency of CSCI 5100: Theory of Computation!\nIt is a pleasure to launch the LaGrange College M.S. in Computer Science (MSCS) with you.\nYou should have:\n\nQuarto running.\nDGitHub pages set up."
  },
  {
    "objectID": "aims.html#sketch",
    "href": "aims.html#sketch",
    "title": "Aims of Education",
    "section": "Sketch",
    "text": "Sketch\n\n\n20 minute intro\n20 guest lecture\n20 minute goal setting\nThen into Theory of Computatation"
  },
  {
    "objectID": "aims.html#about-me",
    "href": "aims.html#about-me",
    "title": "Aims of Education",
    "section": "About Me",
    "text": "About Me\n\n\n\nAbout\nMe\n\n\n\n\nName:\nCalvin (Deutschbein)\n\n\nSay:\n(Professor) Calvin\n\n\nPronoun:\nthey/them\n\n\nOffice:\nDiscord calvin2501\n\n\nEmail:\nckdeutschbein@willamette.edu (@lagrange email Soon™)\n\n\nWebsite:\ncd-public.github.io"
  },
  {
    "objectID": "aims.html#background",
    "href": "aims.html#background",
    "title": "Aims of Education",
    "section": "Background",
    "text": "Background\n\n\nThesis Title: Mining Secure Behavior of Hardware Designs\n\n\nSpecification mining can discover properties that can verify the secure behavior of closed-source CISC CPU designs, the temporal correctness of CPU designs, and hyperproperties for secure information flow in modules, SoCs, and CPUs."
  },
  {
    "objectID": "aims.html#background-1",
    "href": "aims.html#background-1",
    "title": "Aims of Education",
    "section": "Background",
    "text": "Background\n\nPlain English:\nJust as there are bugs in code that make software, modern hardware is also written in code and therefore may contain bugs. I find these bugs.\n\nOf note: I found those bugs using computation theory specifically automata."
  },
  {
    "objectID": "aims.html#course-description",
    "href": "aims.html#course-description",
    "title": "Aims of Education",
    "section": "Course Description",
    "text": "Course Description\n\nStudy of abstract models of computation, unsolvability, complexity theory, formal grammars and parsing, and other advanced topics in theoretical computer science.\n\n~25 contact hours on automata\n~15 contact hours on complexity"
  },
  {
    "objectID": "aims.html#modality",
    "href": "aims.html#modality",
    "title": "Aims of Education",
    "section": "Modality",
    "text": "Modality\n\nAll of automata theory in residency, right now.\nAll of complexity theory in video recordings, over the next 8 weeks.\nI maintain a website with videos, slides, code, and problem sets.\nYou will maintain a website with completed problem sets."
  },
  {
    "objectID": "aims.html#grading",
    "href": "aims.html#grading",
    "title": "Aims of Education",
    "section": "Grading",
    "text": "Grading\n\nWeekly problem sets that will lag (due to the residency) and catch up at the end.\nAll coursework as Python .qmd rendered in .html on GitHub pages.\n“Final” is having a theory of computation website."
  },
  {
    "objectID": "aims.html#feedback-and-grading",
    "href": "aims.html#feedback-and-grading",
    "title": "Aims of Education",
    "section": "Feedback and Grading",
    "text": "Feedback and Grading\n\n“After some consideration, I’ve decided to move away from a traditional grading structure for this class. Rather than assign work with the intent of assessing student progress, assignments in this course will instead focus on fostering student learning. As a result, I intend to implement the following:”\n\n\n\nGeneral Expectations\n\nStudents will begin the course with a grade of an “A”.\n\nStudents will be expected to:\n\nFollow lecture.\nParticipate in Discord.\nTreat fellow students with respect.\nComplete problem sets.\n\n\n\n\n\n\nInstructor Communication\n\nStudents will be contacted privately by the course instructor in the unusual event that they are not meeting expectations.\n\nStudents will not be held to an expectation of perfection.\nStudents will not lose points or grades without prior discussion.\nStudents will have the opportunity to explain their engagement with the course.\n\n\n\n\n\nFeedback Structure\n\nStudents collectively within the class as a whole will receive feedback on computation, automata, and complexity.\n\nIndividual feedback will be provided in limited and unique cases.\nStudents are expected to provide respectfully collaborate on problem sets.\nStudents may request individual feedback from the instructor at any time.\nStudents will receive narrative rather than quantitative feedback."
  },
  {
    "objectID": "aims.html#group-exercise",
    "href": "aims.html#group-exercise",
    "title": "Aims of Education",
    "section": "Group Exercise:",
    "text": "Group Exercise:\n\nLet’s start the class off right away with an exercise designed for:\n\nGroups\n\nDiscussion\n\nDisagreement\n\nDeep critical thinking"
  },
  {
    "objectID": "aims.html#aims-of-education",
    "href": "aims.html#aims-of-education",
    "title": "Aims of Education",
    "section": "Aims of Education",
    "text": "Aims of Education\n\nBefore starting my first degree, we went to a lecture titled “Aims of Education”\nI completed all remaining degrees during shutdowns/other crises!\nI remember it fondly.\nWe will watch “How open-source hardware is changing our future” by Amber Huffman.\n\nAnd then discuss."
  },
  {
    "objectID": "aims.html#question-0",
    "href": "aims.html#question-0",
    "title": "Aims of Education",
    "section": "Question 0",
    "text": "Question 0\n\nWhat are the goals of an education in computer science?\n\n\nThink: about a possible answer individually.\n\nDiscuss: answers within the group.\n\nRecord: a summary of the discussion."
  },
  {
    "objectID": "aims.html#question-1",
    "href": "aims.html#question-1",
    "title": "Aims of Education",
    "section": "Question 1",
    "text": "Question 1\n\nHow does a scientist learn something new?\n\n\nThink: about a possible answer individually.\n\nDiscuss: answers within the group.\n\nRecord: a summary of the discussion."
  },
  {
    "objectID": "aims.html#question-2",
    "href": "aims.html#question-2",
    "title": "Aims of Education",
    "section": "Question 2",
    "text": "Question 2\n\nWhat do you reasonably expect to remember from your courses in 20 years?\n\n\nThink: about a possible answer individually.\n\nDiscuss: answers within the group.\n\nRecord: a summary of the discussion."
  },
  {
    "objectID": "aims.html#question-3",
    "href": "aims.html#question-3",
    "title": "Aims of Education",
    "section": "Question 3",
    "text": "Question 3\n\nWhat is the value of making mistakes in the learning process?\n\n\nThink: about a possible answer individually.\n\nDiscuss: answers within the group.\n\nRecord: a summary of the discussion."
  },
  {
    "objectID": "aims.html#question-4",
    "href": "aims.html#question-4",
    "title": "Aims of Education",
    "section": "Question 4",
    "text": "Question 4\n\nHow do we create a safe environment where risk-taking is encouraged and productive failure is valued?\n\n\nThink: about a possible answer individually.\n\nDiscuss: answers within the group.\n\nRecord: a summary of the discussion."
  },
  {
    "objectID": "aims.html#closing-thoughts",
    "href": "aims.html#closing-thoughts",
    "title": "Aims of Education",
    "section": "Closing Thoughts",
    "text": "Closing Thoughts\n\nTry! Hard work leads to innovative thinking.\n\nFail! Don’t fear failure. Be ready to redo from scratch.\n\nCollaborate! Work with peers to succeed at this course and succeed at collaboration.\nEnjoy! Experience the fun of being a scientist through hard work and exploration."
  },
  {
    "objectID": "01_python.html#why-python",
    "href": "01_python.html#why-python",
    "title": "Python",
    "section": "Why Python?",
    "text": "Why Python?\n\nPython is free,\nPython is very widely used,\nPython is flexible,\nPython is relatively easy to learn,\nand Python is quite powerful."
  },
  {
    "objectID": "01_python.html#why-not-python",
    "href": "01_python.html#why-not-python",
    "title": "Python",
    "section": "Why not Python?",
    "text": "Why not Python?\n\nPython is a general purpose language used for Scientific Computing.\nNot to build apps, build software, manage databases, or develop user interfaces.\nSolve scientific and mathematical problems."
  },
  {
    "objectID": "01_python.html#python-libraries",
    "href": "01_python.html#python-libraries",
    "title": "Python",
    "section": "Python libraries",
    "text": "Python libraries\nThere is an overwhelming abundance of information available about Python and the suite of tools that we will frequently use.\n\nPython,\nnumpy (numerical Python),\nmatplotlib (a suite of plotting tools),\nscipy (scientific Python), and\nsympy (symbolic Python)."
  },
  {
    "objectID": "01_python.html#environments",
    "href": "01_python.html#environments",
    "title": "Python",
    "section": "Environments",
    "text": "Environments\n\nThese slides are written in one environment for writing Python code: Quarto.\n\nRead more\n\nFor scientific computing, often use “Jupter” or “IPython”\n\nUsually through the web at Google Colab\nOr open source via Binder\nCan be used locally, such as in VS Code\nHistorically, via JupyterLab"
  },
  {
    "objectID": "01_python.html#these-slides",
    "href": "01_python.html#these-slides",
    "title": "Python",
    "section": "These slides",
    "text": "These slides\n\nCode blocks will be enclosed in a white box on a black background, with code in a monospace (all characters of the same width) font of slightly smaller size.\nThe code will be syntax highlighted, as it will be highlighted in most programs for writing Python.\nThere will be line numbers.\n\n\nprint(\"I will show code this way on these slides.\")\n\nI will show code this way on these slides.\n\n\n\nThe output of a Python expression will be in white text of the same size and font style under the code block."
  }
]